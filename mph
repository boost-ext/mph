//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef MPH
#define MPH 2'0'1 // SemVer

#if __has_include(<x86intrin.h>)
#include <x86intrin.h> // _pext_u32, _pext_u64
#endif

#if not defined(MPH_PAGE_SIZE)
#define MPH_PAGE_SIZE 4096u // Used for string-like keys if
                            // the input string size is not
                            // known at compile-time
                            // If set to 0u std::memcpy is used instead
#endif

/**
 * Perfect hash library (https://github.com/boost-ext/mph)
 */
namespace mph::inline v2_0_1 {
namespace utility {
using size_t = decltype(sizeof(int));
using uint32_t = unsigned int;
using uint64_t = unsigned long int;
inline constexpr auto char_bit = [] {
  char bit{1};
  size_t n{};
  while (bit) { bit <<= 1; ++n; }
  return n;
}();

template<class T1, class T2>
struct compressed_pair {
  using first_type = T1;
  using second_type = T2;
  [[no_unique_address]] T1 first;
  [[no_unique_address]] T2 second;
};
template<class T1, class T2> compressed_pair(T1, T2) -> compressed_pair<T1, T2>;

template<class T, size_t Size>
struct array {
  using value_type = T;
  [[nodiscard]] constexpr const T* data() const noexcept { return data_; }
  [[nodiscard]] constexpr T* data() noexcept { return data_; }
  [[nodiscard]] constexpr auto size() const noexcept { return Size; }
  [[nodiscard]] constexpr const auto& operator[](size_t i) const noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto& operator[](size_t i) noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto operator==(const array&) const noexcept -> bool = default;
  [[nodiscard]] constexpr auto begin() const noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto begin() noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto end() const noexcept { return &data_[0]+Size; }
  [[nodiscard]] constexpr auto end() noexcept { return &data_[0]+Size; }
  constexpr void fill(const T& value) noexcept { for (auto i = 0u; i < Size; ++i) { data_[i] = value; } }
  T data_[Size];
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;

template<class...> inline constexpr auto is_same_v = false;
template<class T>  inline constexpr auto is_same_v<T, T> = true;

namespace detail {
template <bool> struct conditional;
template <> struct conditional<false> { template <class, class T> using fn = T; };
template <> struct conditional<true>  { template <class T, class> using fn = T; };
}  // namespace detail
template <bool B, class T, class F>
using conditional_t = typename detail::conditional<B>::template fn<T, F>;

template<class T, size_t alignment>
struct aligned {
  using type = struct alignas(alignment) a  : T { };
  static_assert(alignment == alignof(type));
};
template<class T> struct aligned<T, 0u> { using type = T; };
template<class T, size_t alignment>
using aligned_t = typename aligned<T, alignment>::type;
}  // namespace utility

template<class T, utility::size_t MaxSize>
struct basic_fixed_string final {
  constexpr basic_fixed_string() noexcept = default;
  template<utility::size_t Size> constexpr explicit(false) basic_fixed_string(const T (&input)[Size]) noexcept requires (Size-1 <= MaxSize) : size_{Size-1} {
    for (auto i = 0u; i < size_; ++i) { data_[i] = input[i]; } // no null terminated
  }
  [[nodiscard]] constexpr auto data() const noexcept { return data_.data(); }
  [[nodiscard]] constexpr auto size() const noexcept { return size_; }
  [[nodiscard]] constexpr auto operator[](const utility::size_t i) const noexcept -> T { return data_[i]; }
  [[nodiscard]] constexpr auto operator==(const basic_fixed_string&) const noexcept -> bool = default;

  utility::size_t size_{};
  utility::array<T, MaxSize> data_{};
};
using fixed_string = basic_fixed_string<char, sizeof(utility::uint64_t)>;

inline constexpr auto unconditional = []([[maybe_unused]] const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) noexcept {
  return lhs; // [unsafe] returns unconditionally
};

inline constexpr auto conditional = [](const bool cond, const auto lhs, const auto rhs) noexcept {
  return cond ? lhs : rhs; // generates jmp (x86-64)
};

inline constexpr auto likely = [](const bool cond, const auto lhs, const auto rhs) noexcept {
  if (cond) [[likely]] {
    return lhs;
  } else {
    return rhs;
  }
};

inline constexpr auto unlikely = [](const bool cond, const auto lhs, const auto rhs) {
  if (cond) [[unlikely]] {
    return lhs;
  } else {
    return rhs;
  }
};

template<auto Probablity>
inline constexpr auto conditional_probability = [](const bool cond, const auto lhs, const auto rhs) noexcept{
  if (__builtin_expect_with_probability(cond, 1, Probablity)) {
    return lhs;
  } else {
    return rhs;
  }
};

inline constexpr auto branchless = [](const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) noexcept {
  return cond * lhs; // generates cmov (x86-64)
};

namespace detail {
template<class T, template<class, auto> class R, class _, auto Size>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const R<_, Size>& data) noexcept -> T {
  if constexpr (not Size) {
    return T{};
  } else if constexpr (Size == sizeof(T)) {
    return *__builtin_bit_cast(const T*, data.data());
  } else {
    static_assert(Size <= sizeof(T));
    T t{};
    __builtin_memcpy(&t, data.data(), Size);
    return t;
  }
}

template<class T, class cold>
[[nodiscard]] [[gnu::cold]] constexpr auto to(const auto& data) noexcept -> T {
  T t{};
  __builtin_memcpy(&t, data.data(), data.size());
  return t;
}

template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const auto& data) noexcept -> T {
  if constexpr (MPH_PAGE_SIZE) {
    // https://github.com/bminor/glibc/blob/master/sysdeps/generic/memcopy.h#L162
    if ((utility::uint64_t(data.data()) & (MPH_PAGE_SIZE - 1ul)) >= (MPH_PAGE_SIZE - sizeof(T))) [[unlikely]] { // page boundry
      return to<T, class cold>(data);
    }
    T t{};
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    __builtin_memcpy(&t, data.data(), sizeof(T)); // not at page boundry
    #pragma GCC diagnostic pop

    if constexpr (sizeof(T) == sizeof(utility::uint32_t)) {
      return T(_bzhi_u32(t, data.size() * utility::char_bit));
    } else if constexpr (sizeof(T) == sizeof(utility::uint64_t)) {
      return T(_bzhi_u64(t, data.size() * utility::char_bit));
    }
    return t;
  } else {
    T t{};
    __builtin_memcpy(&t, data.data(), data.size());
    return t;
  }
}

template<class T>
[[nodiscard]] constexpr auto as(const auto& value) noexcept -> T requires requires { value.size(); } {
  T result{};
  const auto size = value.size();
  for (auto i = 0u; i < size; ++i) {
    result = (result << utility::char_bit) | value[size - i - 1];
  }
  return result;
}

template<class T>
[[nodiscard]] constexpr auto as(const T& value) noexcept -> const T& {
  return value;
}

template<class T> // https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
[[nodiscard]] constexpr auto pext(const T a, T mask) noexcept {
  T result{};
  auto k = 0u;
  constexpr auto size = sizeof(T) * utility::char_bit;
  for (auto i = T(); i < T(size); ++i) {
    if (mask & 1) result |= ((a >> i) & 1) << k++;
    mask >>= 1;
  }
  return result;
}

#if __has_include(<x86intrin.h>)
[[nodiscard]] [[gnu::target("bmi2")]] inline auto pext(const utility::uint32_t a, const utility::uint32_t mask) noexcept {
  return _pext_u32(a, mask);
}

[[nodiscard]] [[gnu::target("bmi2")]] inline auto pext(const utility::uint64_t a, const utility::uint64_t mask) noexcept {
  return _pext_u64(a, mask);
}
#endif

template<template<class, auto> class C, class T, auto Size>
[[nodiscard]] constexpr auto unique(const C<T, Size>& v) noexcept -> bool {
  for (auto i = 0u; i < Size; ++i) {
    for (auto j = i + 1u; j < Size; ++j) {
      if (v[i] == v[j]) {
        return false;
      }
    }
  }
  return true;
}

template<class T, template<class, auto> class C, class _, auto Size>
[[nodiscard]] constexpr auto pext_mask(const C<_, Size>& v) noexcept -> T {
  utility::array<T, Size> masked;
  T mask{~T{}};
  constexpr auto size = sizeof(T) * utility::char_bit;
  for (int n = size - 1; n >= 0; --n) {
    mask &= ~(T(1) << n);

    for (auto i = 0u; i < Size; ++i) {
      masked[i] = pext<T>(as<T>(v[i].first), mask);
    }

    if (not unique(masked)) {
      mask |= (T(1) << n);
    }
  }
  return mask;
}

[[nodiscard]] constexpr auto cmp(const auto& lhs, const auto& rhs) noexcept
  requires requires { lhs == rhs; } {
  return lhs == rhs;
}
[[nodiscard]] constexpr auto cmp(auto&& lhs, auto&& rhs) noexcept
  requires requires { lhs.size(); rhs.size(); lhs[0]; rhs[0]; } {
  if (lhs.size() != rhs.size()) {
    return false;
  }
  for (auto i = 0u; i < lhs.size(); ++i) {
    if (lhs[i] != rhs[i]) {
      return false;
    }
  }
  return true;
}

[[nodiscard]] constexpr auto max_key_len(const auto& kv) -> utility::size_t
  requires requires { kv[0].first.size(); } {
  auto size = 0u;
  for (const auto& [k, _] : kv) {
    if (k.size() > size) {
      size = k.size();
    }
  }
  return size;
}
[[nodiscard]] constexpr auto max_key_len([[maybe_unused]] const auto& kv) -> utility::size_t { return {}; }

template<class TKey> [[nodiscard]] constexpr auto size(const TKey&) {
  return sizeof(TKey);
}
template<class TKey> [[nodiscard]] constexpr auto size(const TKey& key)
  requires requires { key.size(); } {
  return key.size();
}

template<auto kv> using value_type = typename decltype(kv)::value_type::second_type;
} // namespace detail

template<auto kv, detail::value_type<kv> unknown = detail::value_type<kv>{}, auto...>
  requires requires { kv.size(); } and (kv.size() == 0u)
[[nodiscard]] constexpr auto hash([[maybe_unused]] const auto& key) noexcept -> decltype(unknown) {
  return unknown;
}

template<auto kv, detail::value_type<kv> unknown = detail::value_type<kv>{}, auto...>
  requires requires { kv.size(); } and (kv.size() == 1u)
[[nodiscard]] constexpr auto hash(const auto& key) noexcept -> decltype(unknown)
  requires (not requires { key.size(); }) {
  return detail::cmp(kv[0].first, key) ? kv[0].second : unknown;
}

template<auto kv, detail::value_type<kv> unknown = detail::value_type<kv>{}, auto...>
  requires requires { kv.size(); } and (kv.size() == 2u)
[[nodiscard]] constexpr auto hash(const auto& key) noexcept -> decltype(unknown)
  requires (not requires { key.size(); }) {
  if (detail::cmp(kv[0].first, key)) { return kv[0].second; }
  if (detail::cmp(kv[1].first, key)) { return kv[1].second; }
  return unknown;
}

template<auto kv, detail::value_type<kv> unknown = detail::value_type<kv>{}, auto policy = conditional, auto Size>
  requires requires { kv.size(); } and (kv.size() > 2u)
[[nodiscard]] constexpr auto hash(const decltype(kv[0].first[0]) (&key)[Size]) noexcept -> decltype(unknown) {
  for (const auto& [k, v] : kv) { if (detail::cmp(k, key)) { return v; } }
  return unknown;
}

template<auto kv, detail::value_type<kv> unknown = detail::value_type<kv>{}, auto policy = conditional, utility::size_t alignment = 0u, class TKey, auto max_key_len = detail::max_key_len(kv)>
  requires requires { kv.size(); } and (kv.size() > 2u and kv.size() < (1u<<8u) and max_key_len <= sizeof(utility::uint64_t) and detail::size(kv[0].first) <= sizeof(utility::uint64_t))
[[nodiscard]] [[gnu::target("bmi2")]] constexpr auto hash(const TKey& key) noexcept -> decltype(unknown) {
  if (__builtin_is_constant_evaluated()) {
    for (const auto& [k, v] : kv) { if (detail::cmp(k, key)) { return v; } }
    return unknown;
  }
  return [&] {
    using type = typename decltype(kv)::value_type::first_type;
    using key_type = utility::conditional_t<requires(type t) { t.size(); }, utility::conditional_t<max_key_len <= sizeof(utility::uint32_t), utility::uint32_t, utility::uint64_t>, type>;
    using value_type = typename decltype(kv)::value_type::second_type;
    using mask_type = utility::conditional_t<sizeof(key_type) <= sizeof(utility::uint32_t), utility::uint32_t, utility::uint64_t>;
    static constexpr const mask_type mask = detail::pext_mask<key_type>(kv);
    static constexpr const auto lut = [] {
      utility::aligned_t<utility::array<utility::compressed_pair<key_type, value_type>, (mask_type(1u) << __builtin_popcountll(mask))>, alignment> lut;
      lut.fill(utility::compressed_pair{key_type{}, unknown});
      for (const auto& [key, value] : kv) {
        const auto k = detail::as<key_type>(key);
        const auto p = detail::pext<key_type>(k, mask);
        lut[p] = utility::compressed_pair{k, value};
      }
      return lut;
    }();
    auto&& lhs = [&]() -> decltype(auto) {
      if constexpr (requires { key.size(); }) {
        return detail::to<key_type>(key);
      } else {
        return key;
      }
    }();
    auto&& [rhs, value] = lut[detail::pext(lhs, mask)];
    return policy(lhs == rhs, value, unknown);
  }();
}
}  // namespace mph::inline v2_0_1

#if not defined(DISABLE_STATIC_ASSERT_TESTS)
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (!cond) { void failed(); failed(); } };

  // mph::utility::compressed_pair
  {
    static_assert(1 == mph::utility::compressed_pair{1, 2}.first);
    static_assert(2 == mph::utility::compressed_pair{1, 2}.second);
    static_assert(sizeof(int) + sizeof(int) == sizeof(mph::utility::compressed_pair{int{}, int{}}));
    struct empty { };
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{empty{}, 42}));
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{42, empty{}}));
    static_assert(sizeof(empty) + sizeof(empty) == sizeof(mph::utility::compressed_pair{empty{}, empty{}}));
  }

  // mph::utility::array
  {
    {
      mph::utility::array<mph::utility::size_t, 1> a{};
      expect(1 == a.size());
    }

    {
      mph::utility::array a{1, 2};
      expect(2u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
    }

    {
      expect(mph::utility::array{1, 2} == mph::utility::array{1, 2});
      expect(mph::utility::array{1, 2} != mph::utility::array{1, 3});
    }

    {
      mph::utility::array a{1};
      a[0] = 2;
      expect(2 == a[0]);
    }

    {
      mph::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(a.begin() != a.end());
      expect(a.size() == mph::utility::size_t(a.end() - a.begin()));
      expect(a.end() == a.begin() + a.size());
    }
  }

  // mp::utility::is_same_v
  {
    static_assert(mph::utility::is_same_v<void, void>);
    static_assert(mph::utility::is_same_v<int, int>);
    static_assert(not mph::utility::is_same_v<int, void>);
    static_assert(not mph::utility::is_same_v<void, int>);
    static_assert(not mph::utility::is_same_v<void*, int>);
    static_assert(not mph::utility::is_same_v<int, const int>);
  }

  // mph::utility::conditional_t
  {
    static_assert(mph::utility::is_same_v<void, mph::utility::conditional_t<true, void, int>>);
    static_assert(mph::utility::is_same_v<int, mph::utility::conditional_t<false, void, int>>);
  }

  // mph::utility::aligned_t
  {
    using mph::utility::array;

    static_assert(16u == alignof(mph::utility::aligned_t<array<int, 42>, 16u>));
    static_assert(32u == alignof(mph::utility::aligned_t<array<int, 42>, 32u>));
    static_assert(64u == alignof(mph::utility::aligned_t<array<int, 42>, 64u>));
    static_assert(alignof(int) == alignof(mph::utility::aligned_t<array<int, 42>, 0u>));
  }

  // mph::fixed_string
  {
    static_assert(0u == mph::fixed_string{}.size());
    static_assert(0u == mph::fixed_string{""}.size());
    static_assert(3u == mph::fixed_string{"abc"}.size());
    static_assert('a' == mph::fixed_string{"abc"}[0]);
    static_assert('a' == mph::fixed_string{"abc"}[0]);
    static_assert('b' == mph::fixed_string{"abc"}[1]);
    static_assert('c' == mph::fixed_string{"abc"}[2]);
    static_assert(mph::fixed_string{"abc"} == mph::fixed_string{"abc"});
    static_assert(mph::fixed_string{"foo"} != mph::fixed_string{"bar"});
  }

  // mph::policies
  {
    static_assert(1 == mph::unconditional(true, 1, 2));
    static_assert(1 == mph::unconditional(false, 1, 2));

    static_assert(1 == mph::conditional(true, 1, 2));
    static_assert(2 == mph::conditional(false, 1, 2));

    static_assert(1 == mph::likely(true, 1, 2));
    static_assert(2 == mph::likely(false, 1, 2));

    static_assert(1 == mph::unlikely(true, 1, 2));
    static_assert(2 == mph::unlikely(false, 1, 2));

    static_assert(1 == mph::conditional_probability<1>(true, 1, 2));
    static_assert(2 == mph::conditional_probability<1>(false, 1, 2));

    static_assert(1 == mph::branchless(true, 1, 2));
    static_assert(0 == mph::branchless(false, 1, 2));
  }

  // mph::detail::pext
  {
    static_assert(0b00 == mph::detail::pext(0b00, 0b00));
    static_assert(0b00 == mph::detail::pext(0b01, 0b00));
    static_assert(0b01 == mph::detail::pext(0b01, 0b01));
    static_assert(0b01 == mph::detail::pext(0b01, 0b11));
    static_assert(0b00 == mph::detail::pext(0b01, 0b10));
    static_assert(0b01 == mph::detail::pext(0b11, 0b10));
    static_assert(0b01 == mph::detail::pext(0b11, 0b01));
    static_assert(0b11 == mph::detail::pext(0b11, 0b11));
  }

  // mph::detail::pext_mask
  {
    using mph::utility::uint32_t;
    using mph::utility::array;
    using mph::utility::compressed_pair;

    static_assert(0b10 == mph::detail::pext_mask<uint32_t>(array{compressed_pair{0b10, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::detail::pext_mask<uint32_t>(array{compressed_pair{0b00, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::pext_mask<uint32_t>(array{compressed_pair{0b10, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::pext_mask<uint32_t>(array{compressed_pair{0b11, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::detail::pext_mask<uint32_t>(array{compressed_pair{0b00, 0}, compressed_pair{0b11, 0}}));
  }

  // mph::detail::unique
  {
    using mph::utility::array;

    static_assert(mph::detail::unique(array{1}));
    static_assert(mph::detail::unique(array{1, 2}));
    static_assert(mph::detail::unique(array{1, 2, 3}));
    static_assert(not mph::detail::unique(array{1, 1}));
    static_assert(not mph::detail::unique(array{1, 2, 1}));
    static_assert(not mph::detail::unique(array{1, 2, 3, 2}));
  }

  // mph::detail::as
  {
    using mph::utility::char_bit;
    using mph::utility::array;

    static_assert(int(0) == mph::detail::as<int>(array{0}));
    static_assert(int(1) == mph::detail::as<int>(array{1}));
    static_assert((int(1) << 0) + (int(2) << char_bit) == mph::detail::as<int>(array{1, 2}));
    static_assert((int(1) << 0) + (int(2) << char_bit)  + (int(3) << char_bit*2) == mph::detail::as<int>(array{1, 2, 3}));
  }

  // mph::detail::cmp
  {
    using mph::utility::array;

    static_assert(mph::detail::cmp(0, 0));
    static_assert(mph::detail::cmp(42u, 42u));
    static_assert(mph::detail::cmp(array{1, 2}, array{1, 2}));
    static_assert(not mph::detail::cmp(2, 1));
    static_assert(not mph::detail::cmp(42, 10));
    static_assert(not mph::detail::cmp(array{1}, array{1, 2}));
    static_assert(not mph::detail::cmp(array{1, 2}, array{2}));
    static_assert(not mph::detail::cmp(array{1, 2}, array{2, 1}));
  }

  // mph::detail::max_key_len
  {
    using mph::utility::array;
    using mph::utility::compressed_pair;
    using mph::fixed_string;

    static_assert(1u == mph::detail::max_key_len(array{compressed_pair{fixed_string{"a"}, 0}}));
    static_assert(2u == mph::detail::max_key_len(array{compressed_pair{fixed_string{"a"}, 0}, compressed_pair{fixed_string{"ab"}, 0}}));
    static_assert(3u == mph::detail::max_key_len(array{compressed_pair{fixed_string{"abc"}, 0}, compressed_pair{fixed_string{"ab"}, 0}}));
  }

  // mph::detail::size
  {
    using mph::utility::uint32_t;
    using mph::utility::uint64_t;
    using mph::utility::array;
    using mph::fixed_string;

    static_assert(sizeof(short) == mph::detail::size(short{}));
    static_assert(sizeof(uint32_t) == mph::detail::size(uint32_t{}));
    static_assert(sizeof(uint64_t) == mph::detail::size(uint64_t{}));
    static_assert(1u == mph::detail::size(array{'a'}));
    static_assert(2u == mph::detail::size(array{'a', 'b'}));
    static_assert(3u == mph::detail::size(array{'a', 'b', 'c'}));
    static_assert(3u == mph::detail::size(fixed_string{"abc"}));
  }

  // mph::hash
  {
    using mph::utility::uint32_t;
    using mph::utility::array;
    using mph::utility::compressed_pair;
    using mph::fixed_string;

    // integral
    {
      {
        constexpr array kv{
          compressed_pair{uint32_t(4), uint32_t(2)},
        };

        static_assert(0 == mph::hash<kv, 0>(uint32_t(0)));
        static_assert(0 == mph::hash<kv, 0>(uint32_t(1)));
        static_assert(2 == mph::hash<kv, 0>(uint32_t(4)));
      }

      {
        constexpr array kv{
          compressed_pair{uint32_t(4), uint32_t(2)},
          compressed_pair{uint32_t(42), uint32_t(87)},
          compressed_pair{uint32_t(100), uint32_t(100)},
        };

        static_assert(0 == mph::hash<kv, 0>(uint32_t(0)));
        static_assert(1 == mph::hash<kv, 1>(uint32_t(0)));
        static_assert(2 == mph::hash<kv, 0>(uint32_t(4)));
        static_assert(87 == mph::hash<kv, 0>(uint32_t(42)));
        static_assert(100 == mph::hash<kv, 0>(uint32_t(100)));
      }
    }

    // string-like
    {
      {
        enum class color { red = 1, green = 2, blue = 3 };

        constexpr array kv{
          compressed_pair{fixed_string{"green"}, color::green},
          compressed_pair{fixed_string{"red"}, color::red},
          compressed_pair{fixed_string{"blue"}, color::blue},
        };

        static_assert(color(-1) == mph::hash<kv, color(-1)>("none"));
        static_assert(color(0) == mph::hash<kv, color(0)>("unknown"));
        static_assert(color::red == mph::hash<kv, color(0)>("red"));
        static_assert(color::green == mph::hash<kv, color(0)>("green"));
        static_assert(color::blue == mph::hash<kv, color(0)>("blue"));
      }
    }
  }
}(), true));
#endif
#endif  // MPH
