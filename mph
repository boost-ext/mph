//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#if __cplusplus < 202002L
#error "MPH requires C++20!"
#else
#ifndef MPH
#define MPH 1'0'0

#include <algorithm>
#include <array>
#include <bit>
#include <cassert>
#include <cstdint>
#include <cstring>
#include <new>
#include <numeric>
#include <ranges>
#include <string_view>
#include <type_traits>
#include <vector>

#if __has_include(<x86intrin.h>)
#include <x86intrin.h>
#endif

namespace mph::inline v_1_0_0 {
namespace utility {
#if defined(__cpp_lib_hardware_interference_size)
static constexpr auto cache_line_size = ::std::hardware_constructive_interference_size;
#else
static constexpr auto cache_line_size = 64;  // x86-64
#endif

template <std::size_t N>
  requires(N > 0)
struct bitset final {
  constexpr explicit(true) bitset(const auto value) {
    for (std::size_t i{}; i < N; ++i) {
      bits[i] = value & (1ull << i);
    }
  }
  constexpr auto set(const auto i, const auto value) { bits[i] = value; }
  [[nodiscard]] constexpr auto size() const { return std::size(bits); }
  [[nodiscard]] constexpr auto operator[](const auto i) const { return bits[i]; }
  template <class T>
  [[nodiscard]] constexpr auto to() const -> T
    requires(sizeof(T) * 8 >= N)
  {
    T result{};
    for (auto i = 0u; i < N; ++i) {
      result |= static_cast<T>(bits[i]) << i;
    }
    return result;
  }
  std::array<bool, N> bits{};
};

// clang-format off
static_assert(1 == bitset<1>{1}[0]);
static_assert(0 == bitset<1>{0}[0]);
static_assert(1 == bitset<2>{0b01}[0]);
static_assert(0 == bitset<2>{0b01}[1]);
static_assert(0b01 == bitset<2>{0b01}.to<int>());
static_assert(0b10 == bitset<2>{0b10}.to<int>());
// clang-format on

template <class T>
[[nodiscard]] constexpr auto as(const auto value) -> T {
  T result{};
  for (auto i = 0u; i < std::min(std::size(value), sizeof(T)); ++i) {
    result = (result << 8) | value[std::min(std::size(value), sizeof(T)) - 1 - i];  // little-endian
  }
  return result;
}

// clang-format off
static_assert(std::is_same_v<std::uint16_t, decltype(as<std::uint16_t>(std::array<std::uint8_t, 2>{0, 1}))>);
static_assert(std::uint32_t(0b00000001'00000000) == as<std::uint16_t>(std::array<std::uint8_t, 2>{0, 1}));
static_assert(std::is_same_v<std::uint16_t, decltype(as<std::uint16_t>( std::array<std::uint8_t, 2>{1, 0}))>);
static_assert(std::uint32_t(0b00000000'00000001) == as<std::uint16_t>(std::array<std::uint8_t, 2>{1, 0}));
static_assert(std::is_same_v<std::uint8_t, decltype(as<std::uint8_t>(std::string_view{"a"}))>);
static_assert(std::uint8_t('a') == as<std::uint8_t>(std::string_view{"a"}));
static_assert(std::is_same_v<std::uint32_t, decltype(as<std::uint32_t>(std::array<std::uint8_t, 4>{ 'a', 'b', 0, 0}))>);
static_assert(((std::uint32_t('b') << 8) | std::uint32_t('a') << 0) == as<std::uint32_t>(std::array<std::uint8_t, 4>{'a', 'b', 0, 0}));
static_assert(std::is_same_v<std::uint32_t, decltype(as<std::uint32_t>(std::array<std::uint8_t, 4>{0, 0, 'a', 'b'}))>);
static_assert(((std::uint32_t('b') << 24) | std::uint32_t('a') << 16) == as<std::uint32_t>(std::array<std::uint8_t, 4>{0, 0, 'a', 'b'}));
// clang-format on

/**
 * https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
 *
 * DO WHILE m < 64
 * 	IF mask[m] == 1
 * 		dst[k] := tmp[m]
 * 		k := k + 1
 * 	FI
 * 	m := m + 1
 * OD
 */
template <class T>
[[nodiscard]] constexpr auto pext(const T a, T mask) {
  T result{};
  auto k = 0u;
  auto m = 0u;
  while (m < sizeof(T) * 8) {
    if ((mask & 1) == 1) {
      result |= ((a >> m) & 1) << k++;
    }
    mask >>= 1;
    ++m;
  }
  return result;
}

// clang-format off
static_assert(0b00 == pext(0b00, 0b00));
static_assert(0b00 == pext(0b01, 0b00));
static_assert(0b01 == pext(0b01, 0b01));
static_assert(0b01 == pext(0b01, 0b11));
static_assert(0b00 == pext(0b01, 0b10));
static_assert(0b01 == pext(0b11, 0b10));
static_assert(0b01 == pext(0b11, 0b01));
static_assert(0b11 == pext(0b11, 0b11));
// clang-format on

/**
 * Finds T type mask which uniquly identifies given symbols
 */
template <class T>
[[nodiscard]] constexpr auto mask(const std::ranges::range auto &symbols) {
  constexpr auto is_unique = [](const auto &symbols, const auto mask) {
    std::vector<T> v{};
    for (const auto &symbol : symbols) {
      const auto value = pext(as<T>(symbol), mask.template to<T>());
      if (std::find(std::cbegin(v), std::cend(v), value) != std::cend(v)) {
        return false;
      }
      v.push_back(value);
    }
    return true;
  };

  bitset<sizeof(T) * 8> mask(std::numeric_limits<T>::max());
  for (auto i = 0u; i < std::size(mask); ++i) {
    mask.set(i, 0);
    if (not is_unique(symbols, mask)) {
      mask.set(i, 1);
    }
  }
  if (not is_unique(symbols, mask)) {
    throw;  // not a constant
  }
  return mask.template to<T>();
}

// clang-format off
static_assert(0b00000000'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 0}, std::array<std::uint8_t, 2>{0, 0}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{0, 0}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 0}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{0, 1}, std::array<std::uint8_t, 2>{1, 0}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 1}, std::array<std::uint8_t, 2>{1, 0}}));
static_assert(0b00000000'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 1}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000000'00000001'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{1, 1, 1}, std::array<std::uint8_t, 3>{0, 0, 0}, std::array<std::uint8_t, 3>{1, 0, 1}}));
static_assert(0b00000000'00000001'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{0, 0, 1}, std::array<std::uint8_t, 3>{1, 0, 1}, std::array<std::uint8_t, 3>{1, 1, 0}}));
static_assert(0b00000000'00000001'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{0, 0, 0}, std::array<std::uint8_t, 3>{1, 1, 1}, std::array<std::uint8_t, 3>{0, 1, 0}}));
// clang-format on
}  // namespace utility

namespace concepts {
template <const std::uint64_t mask, const std::size_t max_bits_size>
concept required_bits_size = std::popcount(mask) <=
max_bits_size;

// clang-format off
static_assert(required_bits_size<0b00, 0u>);
static_assert(required_bits_size<0b00, 1u>);
static_assert(required_bits_size<0b00, 2u>);
static_assert(required_bits_size<0b10, 2u>);
static_assert(required_bits_size<0b01, 2u>);
static_assert(not required_bits_size<0b01, 0>);
static_assert(not required_bits_size<0b10, 0>);
static_assert(not required_bits_size<0b11, 1>);
// clang-format on

template <const auto masks, const std::size_t max_bits_size>
concept required_symbols_bits_size = std::all_of(std::cbegin(masks), std::cend(masks), [](const auto mask) {
  return std::size_t(std::popcount(mask)) <= max_bits_size;
});

// clang-format off
static_assert(required_symbols_bits_size<std::array{0b00u, 0b00u}, 0u>);
static_assert(required_symbols_bits_size<std::array{0b01u, 0b01u}, 1u>);
static_assert(required_symbols_bits_size<std::array{0b10u, 0b01u}, 1u>);
static_assert(not required_symbols_bits_size<std::array{0b01u, 0b01u}, 0u>);
static_assert(not required_symbols_bits_size<std::array{0b11u, 0b10u}, 1u>);
static_assert(not required_symbols_bits_size<std::array{0b10u, 0b11u}, 1u>);
static_assert(not required_symbols_bits_size<std::array{0b11u, 0b11u}, 1u>);
// clang-format on

template <class TSymbols, std::size_t Size>
concept supported_symbols_size = [](const auto &symbols) {
  return std::all_of(std::cbegin(symbols), std::cend(symbols), [](const auto &symbol) { return std::size(symbol) <= Size; });
}(TSymbols{}());

// clang-format off
static_assert(supported_symbols_size<decltype([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }), 1u>);
static_assert(supported_symbols_size<decltype([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }), 2u>);
static_assert(supported_symbols_size<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 2u>);
static_assert(supported_symbols_size<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 3u>);
static_assert(not supported_symbols_size<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 0u>);
static_assert(not supported_symbols_size<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 1u>);
// clang-format on
}  // namespace concepts

/*
 * @return 0 if string doesn't match, 1..N for matches
 *  - requires symbols to have the same size <= 8 bytes
 *  - requires platform with bmi2 support (https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set)
 */
template <const std::size_t max_bits_size = 5, const std::size_t cache_line_size = utility::cache_line_size>
class pext_direct {
  using T = std::uint64_t;

  template <const auto mask>
  [[nodiscard]] static constexpr auto make_lut(const auto &symbols) {
    alignas(cache_line_size) std::array<T, 32> lut{};
    for (const auto &symbol : symbols()) {
      lut[utility::pext(utility::as<T>(symbol), mask)] = utility::as<T>(symbol);
    }
    return lut;
  }

  template <const auto mask>
  [[nodiscard]] static constexpr auto make_index(const auto &symbols) {
    constexpr auto size = [] {  // std::pow is not constexpr
      std::size_t result{1};
      for (auto i = 0u; i < std::popcount(mask); ++i) {
        result *= 2;
      }
      return result;
    }();

    alignas(cache_line_size) std::array<T, size> index{};
    for (auto i = 0u; const auto &symbol : symbols()) {
      index[utility::pext(utility::as<T>(symbol), mask)] = ++i;
    }
    return index;
  }

 public:
  template <class TSymbols, const auto mask = utility::mask<T>(TSymbols{}())>
    requires concepts::required_bits_size<mask, max_bits_size> and concepts::supported_symbols_size<TSymbols, sizeof(T)>
  [[nodiscard]] [[gnu::target("bmi2")]] auto operator()(const TSymbols s, const auto *data, const auto size,
                                                        [[maybe_unused]] auto &&...args) const noexcept(true) {
    const auto lhs = [&] {
      if constexpr (requires { size.unknown; }) {
        return *std::bit_cast<const T *>(data);
      } else {
        T t{};
        std::memcpy(&t, data, size);
        return t;
      }
    }();

    static constexpr const auto lut = make_lut<mask>(s);
    static constexpr const auto index = make_index<mask>(s);

    if (const auto ext = _pext_u64(lhs, mask); lut[ext] == lhs) {
      return index[ext];
    } else {
      return decltype(index[ext]){};
    }
  }
};

template <const std::size_t max_bits_size = 5, const std::size_t cache_line_size = utility::cache_line_size>
class pext_split_on_first_char {
  using T = std::uint64_t;

  [[nodiscard]] static constexpr auto make_masks(const auto &symbols) {
    constexpr auto size = std::numeric_limits<std::remove_cvref_t<decltype(symbols()[0][0])>>::max();
    std::vector<std::vector<std::string_view>> v(size);
    for (const auto &symbol : symbols()) {
      v[symbol[0]].push_back(symbol);
    }
    std::array<T, size> masks{};
    for (auto i = 0u; i < std::size(masks); ++i) {
      masks[i] = utility::mask<T>(v[i]);
    }
    return masks;
  }

  template <const auto C, const auto mask>
  [[nodiscard]] static constexpr auto make_lut(const auto &symbols) {
    alignas(cache_line_size) std::array<T, 32> lut{};
    for (const auto &symbol : symbols()) {
      if (symbol[0] == C) {
        lut[utility::pext(utility::as<T>(symbol), mask)] = utility::as<T>(symbol);
      }
    }
    return lut;
  }

  template <const auto C, const auto mask>
  [[nodiscard]] static constexpr auto make_index(const auto &symbols) {
    constexpr auto size = [] {  // std::pow is not constexpr
      std::size_t result{1};
      for (auto i = 0u; i < std::popcount(mask); ++i) {
        result *= 2;
      }
      return result;
    }();

    alignas(cache_line_size) std::array<T, size> index{};
    for (auto i = 1u; const auto &symbol : symbols()) {
      if (symbol[0] == C) {
        index[utility::pext(utility::as<T>(symbol), mask)] = i;
      }
      ++i; // global index across different symbols
    }
    return index;
  }

 public:
  template <class TSymbols, const auto masks = make_masks(TSymbols{})>
    requires concepts::required_symbols_bits_size<masks, max_bits_size> and
             concepts::supported_symbols_size<TSymbols, sizeof(T)>
  [[nodiscard]] [[gnu::target("bmi2")]] auto operator()(const TSymbols s, const auto *data, const auto size,
                                                        [[maybe_unused]] auto &&...args) const noexcept(true) {
    constexpr auto unique = [](const auto &symbols) {
      std::array<bool, 255> a{};
      for (const auto &symbol : symbols) {
        a[symbol[0]] = true;
      }
      return a;
    }(s());

    return [&]<auto... Ns>(std::index_sequence<Ns...>) {
      return dispatch<masks, std::pair{Ns, unique[Ns]}...>(
          s,
          [&] {
            if constexpr (requires { size.unknown; }) {
              return *std::bit_cast<const T *>(data);
            } else {
              assert(size > 0);
              T t{};
              std::memcpy(&t, data, size);
              return t;
            }
          }(),
          data);
    }
    (std::make_index_sequence<std::size(unique)>{});
  }

 private:
  template <const auto masks, const auto C, const auto... Cs>
  [[nodiscard]] static auto dispatch(const auto symbols, const auto lhs, const auto *data) noexcept(true) {
    if constexpr (not sizeof...(Cs)) {
      // return decltype(index[0]){};
      return 0ul;
    } else if constexpr (C.second) {
      switch (data[0]) {
        case C.first: {
          static constexpr auto mask = masks[C.first];
          static constexpr auto lut = make_lut<C.first, mask>(symbols);
          static constexpr auto index = make_index<C.first, mask>(symbols);

          if (const auto ext = _pext_u64(lhs, mask); lut[ext] == lhs) {
            return index[ext];
          } else {
            return decltype(index[0]){};
          }
        }
        default:
          return dispatch<masks, Cs...>(symbols, lhs, data);
      }
    } else {
      return dispatch<masks, Cs...>(symbols, lhs, data);
    }
  }
};

/**
 * Default implementation for picking the policy based on the symbols, available policies and the input data
 * @param symbols constexpr list of symbols
 * @param data continuous input data
 * @param size input size
 * @param args... additional args propagated to policies
 * @return 0 if string doesn't match, 1..N for matches
 */
constexpr auto default_policies = [](const auto symbols, const auto *data, const auto size, auto &&...args) {
  if constexpr (constexpr auto max_bits_size = 5;
                requires { pext_direct<max_bits_size>{}(symbols, data, size, std::forward<decltype(args)>(args)...); }) {
    return pext_direct<max_bits_size>{}(symbols, data, size, std::forward<decltype(args)>(args)...);
  } else if constexpr (requires {
                         pext_split_on_first_char<max_bits_size>{}(symbols, data, size, std::forward<decltype(args)>(args)...);
                       }) {
    return pext_split_on_first_char<max_bits_size>{}(symbols, data, size, std::forward<decltype(args)>(args)...);
  } else {
    constexpr auto always_false = [](auto &&) { return false; }(data);  // static_assert(false) support is C++23
    static_assert(always_false, "hash can't be constructed with given policies!");
  }
  // will fail if policies don't return the same type
};

/**
 * Minimal perfect hash function (https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function)
 *
 * @tparam TSymbols compile time array of symbols
 * @tparam TPolicies compile time policies to be executed in given order
 */
template <std::invocable TSymbols, class TPolicies = decltype(default_policies)>
class hash final {
  struct unknown_size final {
    static constexpr auto unknown = true;  // tag for `if constexpr (requires { size.unknown; })`
  };

 public:
  constexpr explicit(true) hash(const TSymbols &symbols, const TPolicies &policies = {})
      : symbols{symbols}, policies{policies} {}

  /**
   * @param data continuous input data
   * @param args... additonal parameters propagated to policies
   * @return result from executed policy
   */
  template <class T, std::size_t Size>
    requires(sizeof(T) == 1u)
  [[nodiscard]] constexpr auto operator()(const T (&&data)[Size], auto &&...args) const noexcept(true) {
    constexpr auto symbols = this->symbols();
    constexpr auto min_max =
        std::minmax_element(std::cbegin(symbols), std::cend(symbols),
                            [](const auto &lhs, const auto &rhs) { return std::size(lhs) < std::size(rhs); });
    if constexpr (Size < min_max.first or Size > min_max.second) {
      return decltype(policies(this->symbols, data, std::integral_constant<decltype(Size), Size>{},
                               std::forward<decltype(args)>(args)...)){};
    } else {
      return policies(this->symbols, data, std::integral_constant<decltype(Size), Size>{},
                      std::forward<decltype(args)>(args)...);
    }
  }

  /**
   * @param data continuous input data
   * @param args... additional parameters propagated to policies
   * @return result from executed policy
   */
  template <class T>
    requires(sizeof(T) == 1u)
  [[nodiscard]] constexpr auto operator()(const T *const data, auto &&...args) const noexcept(true) {
    assert(data);
    return policies(this->symbols, data, unknown_size{}, std::forward<decltype(args)>(args)...);
  }

  /**
   * @param data continuous input data
   * @param args... additonal parameters propagated to policies
   * @return result from executed policy
   */
  template <class T, class... Ts>
    requires(sizeof(T) == 1u)
  [[nodiscard]] constexpr auto operator()(const std::basic_string_view<T, Ts...> data, auto &&...args) const noexcept(true) {
    return policies(this->symbols, std::data(data), std::size(data), std::forward<decltype(args)>(args)...);
  }

  TSymbols symbols{};
  [[no_unique_address]] TPolicies policies{};
};
}  // namespace mph::inline v_1_0_0
#endif  // MPH
#endif  //  __cplusplus
