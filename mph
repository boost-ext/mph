//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef MPH
#define MPH 2'2'0 // SemVer

/**
 * Perfect hash library (https://github.com/boost-ext/mph)
 */
namespace mph::inline v2_2_0 {
namespace utility {
using size_t = decltype(sizeof(int));
using uint32_t = unsigned int;
using uint64_t = unsigned long int;

template<class T1, class T2>
struct compressed_pair {
  using first_type = T1;
  using second_type = T2;
  [[no_unique_address]] T1 first;
  [[no_unique_address]] T2 second;
};
template<class T1, class T2> compressed_pair(T1, T2) -> compressed_pair<T1, T2>;

template<class T, size_t Size>
struct array {
  using value_type = T;
  [[nodiscard]] constexpr const T* data() const noexcept { return data_; }
  [[nodiscard]] constexpr T* data() noexcept { return data_; }
  [[nodiscard]] constexpr auto size() const noexcept { return Size; }
  [[nodiscard]] constexpr const auto& operator[](size_t i) const noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto& operator[](size_t i) noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto operator==(const array&) const noexcept -> bool = default;
  [[nodiscard]] constexpr auto begin() const noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto begin() noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto end() const noexcept { return &data_[0]+Size; }
  [[nodiscard]] constexpr auto end() noexcept { return &data_[0]+Size; }
  constexpr void fill(const T& value) noexcept { for (auto i = 0u; i < Size; ++i) { data_[i] = value; } }
  T data_[Size];
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;

template<class...> inline constexpr auto is_same_v = false;
template<class T>  inline constexpr auto is_same_v<T, T> = true;

namespace detail {
template <bool> struct conditional;
template <> struct conditional<false> { template <class, class T> using fn = T; };
template <> struct conditional<true>  { template <class T, class> using fn = T; };
}  // namespace detail
template <bool B, class T, class F>
using conditional_t = typename detail::conditional<B>::template fn<T, F>;

template<class T, size_t alignment>
struct aligned {
  using type = struct alignas(alignment) a  : T { };
  static_assert(alignment == alignof(type));
};
template<class T> struct aligned<T, 0u> { using type = T; };
template<class T, size_t alignment>
using aligned_t = typename aligned<T, alignment>::type;
} // namespace utility

template<class T, utility::size_t MaxSize>
struct basic_fixed_string {
  constexpr basic_fixed_string() noexcept = default;
  template<utility::size_t Size>
  constexpr explicit(false) basic_fixed_string(const T (&input)[Size]) noexcept
    requires (Size - 1 <= MaxSize) : size_{Size - 1} {
    for (auto i = 0u; i < size_; ++i) { data_[i] = input[i]; } // no null terminated
  }
  [[nodiscard]] constexpr auto data() const noexcept { return data_.data(); }
  [[nodiscard]] constexpr auto size() const noexcept { return size_; }
  [[nodiscard]] constexpr auto operator[](const utility::size_t i) const noexcept -> T { return data_[i]; }
  [[nodiscard]] constexpr auto operator==(const basic_fixed_string&) const noexcept -> bool = default;

  utility::size_t size_{};
  utility::array<T, MaxSize> data_{};
};
using fixed_string = basic_fixed_string<char, sizeof(utility::uint64_t)>;

inline constexpr auto unconditional =
  []([[maybe_unused]] const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) noexcept {
    return lhs; // [unsafe] returns unconditionally
  };

inline constexpr auto conditional =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    return cond ? lhs : rhs; // generates jmp (x86-64)
  };

inline constexpr auto likely =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    if (cond) [[likely]] {
      return lhs;
    } else {
      return rhs;
    }
  };

inline constexpr auto unlikely =
  [](const bool cond, const auto lhs, const auto rhs) {
    if (cond) [[unlikely]] {
      return lhs;
    } else {
      return rhs;
    }
  };

template<auto Probablity>
inline constexpr auto conditional_probability =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    if (__builtin_expect_with_probability(cond, 1, Probablity)) {
      return lhs;
    } else {
      return rhs;
    }
  };

inline constexpr auto branchless =
  [](const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) noexcept {
    return cond * lhs; // more likely to generate cmov (x86-64)
  };

#if defined(__clang__)
inline constexpr auto unpredictable =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    if (__builtin_unpredictable(cond)) { // generates cmov (x86-64)
      return lhs;
    } else {
      return rhs;
    }
  };
#endif

#if not defined(MPH_CHAR_BIT)
#define MPH_CHAR_BIT 8u
#endif

namespace detail {
template<class T>
[[nodiscard]] constexpr decltype(auto) as(const auto& value) noexcept {
  if constexpr (requires { value.size(); }) {
    T result{};
    const auto size = value.size();
    for (auto i = 0u; i < size; ++i) {
      result = (result << MPH_CHAR_BIT) | value[size - i - 1];
    }
    return result;
  } else {
    return value;
  }
}

/// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
template<class T, T size = sizeof(T) * MPH_CHAR_BIT>
[[nodiscard]] constexpr auto pext(const T a, T mask) noexcept {
  T result{};
  auto k = 0u;
  for (T i{}; i < size; ++i) {
    if (mask & 1) result |= ((a >> i) & 1) << k++;
    mask >>= 1;
  }
  return result;
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto pext(const utility::uint32_t a, const utility::uint32_t mask) noexcept {
  return __builtin_ia32_pext_si(a, mask);
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto pext(const utility::uint64_t a, const utility::uint64_t mask) noexcept {
  return __builtin_ia32_pext_di(a, mask);
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto bzhi(const utility::uint32_t src, const utility::uint32_t index) noexcept {
  return __builtin_ia32_bzhi_si(src, index);
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto bzhi(const utility::uint64_t src, const utility::uint64_t index) noexcept {
  return __builtin_ia32_bzhi_di(src, index);
}

template<class T, template<class, auto> class C, class _, auto Size, auto size = sizeof(T) * MPH_CHAR_BIT>
[[nodiscard]] constexpr auto mask(const C<_, Size>& v) noexcept -> T {
  utility::array<T, Size> vs;
  T max{};
  for (auto i = 0u; i < Size; ++i) {
    vs[i] = as<T>(v[i].first);
    if (vs[i] > max) {
      max = vs[i];
    }
  }
  utility::array<utility::compressed_pair<bool, T>, Size> hashed;
  const auto nbits = size - __builtin_clz(max) - 1;
  T mask{(T(1) << nbits) - 1};
  for (int n = nbits; n >= 0; --n) {
    mask &= ~(T(1) << n);
    hashed = {};
    for (auto i = 0u; i < Size; ++i) {
      const auto masked = vs[i] & mask;
      auto hash = masked % Size;
      while (hashed[hash].first and hashed[hash].second != masked) {
        hash = (hash + 1) % Size;
      }
      if (hashed[hash].first and hashed[hash].second == masked) {
        mask |= (T(1) << n);
        break;
      }
      hashed[hash] = {true, masked};
    }
  }
  return mask;
}

template<class T, template<class, auto> class R, class _, auto Size>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const R<_, Size>& data) noexcept -> T {
  if constexpr (not Size) {
    return T{};
  } else if constexpr (Size == sizeof(T)) {
    return *__builtin_bit_cast(const T*, data.data());
  } else if constexpr (Size <= sizeof(T)) {
    T t{};
    __builtin_memcpy(&t, data.data(), Size);
    return t;
  }
}

template<class T, class cold>
[[nodiscard]] [[gnu::cold]] constexpr auto to(const auto& data) noexcept -> T {
  T t{};
  __builtin_memcpy(&t, data.data(), data.size());
  return t;
}

template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const auto& data) noexcept -> T {
  #if not defined(MPH_PAGE_SIZE)
  #define MPH_PAGE_SIZE 4096u // Used for string-like keys if
                              // the input string size is not
                              // known at compile-time
                              // If set to 0u __builtin_memcpy is used instead
  #endif

  if constexpr (MPH_PAGE_SIZE) {
    // https://github.com/bminor/glibc/blob/master/sysdeps/generic/memcopy.h#L162
    if ((utility::uint64_t(data.data()) & (MPH_PAGE_SIZE - 1ul)) >= (MPH_PAGE_SIZE - sizeof(T))) [[unlikely]] { // page boundry
      return to<T, class cold>(data);
    }
    T t{};
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    __builtin_memcpy(&t, data.data(), sizeof(T)); // not at page boundry
    #pragma GCC diagnostic pop

    if constexpr (sizeof(T) == sizeof(utility::uint32_t)) {
      return T(bzhi(t, T(data.size() * MPH_CHAR_BIT)));
    } else if constexpr (sizeof(T) == sizeof(utility::uint64_t)) {
      return T(bzhi(t, T(data.size() * MPH_CHAR_BIT)));
    }
    return t;
  } else {
    T t{};
    __builtin_memcpy(&t, data.data(), data.size());
    return t;
  }
}

[[nodiscard]] constexpr auto cmp(const auto& lhs, const auto& rhs) noexcept -> bool {
  if constexpr (requires { lhs.size(); rhs.size(); lhs[0]; rhs[0]; }) {
    if (lhs.size() != rhs.size()) {
      return false;
    }
    for (auto i = 0u; i < lhs.size(); ++i) {
      if (lhs[i] != rhs[i]) {
        return false;
      }
    }
    return true;
  } else if constexpr (requires { lhs == rhs; }) {
    return lhs == rhs;
  } else {
    return {};
  }
}

[[nodiscard]] constexpr auto max_key_len([[maybe_unused]] const auto& kv) -> utility::size_t {
  if constexpr (requires { kv[0].first.size(); }) {
    auto size = 0u;
    for (const auto& [k, _] : kv) {
      if (k.size() > size) {
        size = k.size();
      }
    }
    return size;
  } else {
    return {};
  }
}

template<class TKey> [[nodiscard]] constexpr auto size(const TKey& key) {
  if constexpr (requires { key.size(); }) {
    return key.size();
  } else {
    return sizeof(TKey);
  }
}
} // namespace detail

template<
  auto kv,
  typename decltype(kv)::value_type::second_type unknown = typename decltype(kv)::value_type::second_type{},
  auto policy = conditional,
  utility::size_t alignment = utility::size_t{}, // no alignment is set
  auto max_key_len = detail::max_key_len(kv)
> requires
    requires { kv.size(); } and (
      kv.size() >= 0u and
      max_key_len <= sizeof(utility::uint64_t) and
      detail::size(kv[0].first) <= sizeof(utility::uint64_t)
    )
[[nodiscard]] [[gnu::target("bmi2")]] constexpr auto hash(const auto& key) noexcept -> decltype(unknown) {
  static_assert([] {
    for (const auto& [_, v] : kv) { if (detail::cmp(v, unknown)) { return false; } }
    return true;
  }(), "[error] `unknown` can't be found in `keys`!");
  if constexpr (kv.size() == 0u) {
    return unknown;
  } else if constexpr (not requires { key.size(); } and kv.size() == 1u) {
    return detail::cmp(kv[0].first, key) ? kv[0].second : unknown;
  } else if constexpr (not requires { key.size(); } and kv.size() == 2u) {
    if (detail::cmp(kv[0].first, key)) { return kv[0].second; }
    if (detail::cmp(kv[1].first, key)) { return kv[1].second; }
  } else if (__builtin_is_constant_evaluated()) {
    for (const auto& [k, v] : kv) { if (detail::cmp(k, key)) { return v; } }
    return unknown;
  } else {
    return [&] {
      using type = typename decltype(kv)::value_type::first_type;
      using key_type = utility::conditional_t<
        requires(type t) { t.size(); },
        utility::conditional_t<
          max_key_len <= sizeof(utility::uint32_t),
          utility::uint32_t,
          utility::uint64_t
        >,
        type
      >;
      using value_type = typename decltype(kv)::value_type::second_type;
      using mask_type = utility::conditional_t<
        sizeof(key_type) <= sizeof(utility::uint32_t),
        utility::uint32_t,
        utility::uint64_t
      >;
      static constexpr const mask_type mask = detail::mask<key_type>(kv);
      static_assert(mask != ~mask_type{}, "[error] mask can't be found!");
      static constexpr const auto lut = [] {
        utility::aligned_t<
          utility::array<
            utility::compressed_pair<key_type, value_type>,
            (mask_type(1u) << __builtin_popcountll(mask))
          >, alignment
        > lut;
        lut.fill(utility::compressed_pair{key_type{}, unknown});
        for (const auto& [key, value] : kv) {
          const auto k = detail::as<key_type>(key);
          const auto p = detail::pext<key_type>(k, mask);
          lut[p] = utility::compressed_pair{k, value};
        }
        return lut;
      }();
      auto&& lhs = [&]() -> decltype(auto) {
        if constexpr (requires { key.size(); }) {
          return detail::to<key_type>(key);
        } else {
          return key;
        }
      }();
      auto&& [rhs, value] = lut[detail::pext(lhs, mask)];
      return policy(lhs == rhs, value, unknown);
    }();
  }
}
} // namespace mph::inline v2_2_0

#if not defined(DISABLE_STATIC_ASSERT_TESTS)
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // mph::utility::compressed_pair
  {
    static_assert(1 == mph::utility::compressed_pair{1, 2}.first);
    static_assert(2 == mph::utility::compressed_pair{1, 2}.second);
    static_assert(sizeof(int) + sizeof(int) == sizeof(mph::utility::compressed_pair{int{}, int{}}));
    struct empty { };
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{empty{}, 42}));
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{42, empty{}}));
    static_assert(sizeof(empty) + sizeof(empty) == sizeof(mph::utility::compressed_pair{empty{}, empty{}}));
  }

  // mph::utility::array
  {
    {
      mph::utility::array<mph::utility::size_t, 1> a{};
      expect(1 == a.size());
    }

    {
      mph::utility::array a{1, 2};
      expect(2u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
    }

    {
      expect(mph::utility::array{1, 2} == mph::utility::array{1, 2});
      expect(mph::utility::array{1, 2} != mph::utility::array{1, 3});
    }

    {
      mph::utility::array a{1};
      a[0] = 2;
      expect(2 == a[0]);
    }

    {
      mph::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(a.begin() != a.end());
      expect(a.size() == mph::utility::size_t(a.end() - a.begin()));
      expect(a.end() == a.begin() + a.size());
    }
  }

  // mp::utility::is_same_v
  {
    static_assert(mph::utility::is_same_v<void, void>);
    static_assert(mph::utility::is_same_v<int, int>);
    static_assert(not mph::utility::is_same_v<int, void>);
    static_assert(not mph::utility::is_same_v<void, int>);
    static_assert(not mph::utility::is_same_v<void*, int>);
    static_assert(not mph::utility::is_same_v<int, const int>);
  }

  // mph::utility::conditional_t
  {
    static_assert(mph::utility::is_same_v<void, mph::utility::conditional_t<true, void, int>>);
    static_assert(mph::utility::is_same_v<int, mph::utility::conditional_t<false, void, int>>);
  }

  // mph::utility::aligned_t
  {
    using mph::utility::array;

    static_assert(16u == alignof(mph::utility::aligned_t<array<int, 42>, 16u>));
    static_assert(32u == alignof(mph::utility::aligned_t<array<int, 42>, 32u>));
    static_assert(64u == alignof(mph::utility::aligned_t<array<int, 42>, 64u>));
    static_assert(alignof(int) == alignof(mph::utility::aligned_t<array<int, 42>, 0u>));
  }

  // mph::fixed_string
  {
    static_assert(0u == mph::fixed_string{}.size());
    static_assert(0u == mph::fixed_string{""}.size());
    static_assert(3u == mph::fixed_string{"abc"}.size());
    static_assert('a' == mph::fixed_string{"abc"}[0]);
    static_assert('a' == mph::fixed_string{"abc"}[0]);
    static_assert('b' == mph::fixed_string{"abc"}[1]);
    static_assert('c' == mph::fixed_string{"abc"}[2]);
    static_assert(mph::fixed_string{"abc"} == mph::fixed_string{"abc"});
    static_assert(mph::fixed_string{"foo"} != mph::fixed_string{"bar"});
  }

  // mph::policies
  {
    static_assert(1 == mph::unconditional(true, 1, 2));
    static_assert(1 == mph::unconditional(false, 1, 2));

    static_assert(1 == mph::conditional(true, 1, 2));
    static_assert(2 == mph::conditional(false, 1, 2));

    static_assert(1 == mph::likely(true, 1, 2));
    static_assert(2 == mph::likely(false, 1, 2));

    static_assert(1 == mph::unlikely(true, 1, 2));
    static_assert(2 == mph::unlikely(false, 1, 2));

    static_assert(1 == mph::conditional_probability<1>(true, 1, 2));
    static_assert(2 == mph::conditional_probability<1>(false, 1, 2));

    static_assert(1 == mph::branchless(true, 1, 2));
    static_assert(0 == mph::branchless(false, 1, 2));
  }

  // mph::detail::pext
  {
    static_assert(0    == mph::detail::pext(0b00, 0b00));
    static_assert(0    == mph::detail::pext(0b01, 0b00));
    static_assert(0b1  == mph::detail::pext(0b01, 0b01));
    static_assert(0b01 == mph::detail::pext(0b01, 0b11));
    static_assert(0b0  == mph::detail::pext(0b01, 0b10));
    static_assert(0b1  == mph::detail::pext(0b11, 0b10));
    static_assert(0b1  == mph::detail::pext(0b11, 0b01));
    static_assert(0b11 == mph::detail::pext(0b11, 0b11));
  }

  // mph::detail::mask
  {
    using mph::utility::uint32_t;
    using mph::utility::array;
    using mph::utility::compressed_pair;

    static_assert(0b10 == mph::detail::mask<uint32_t>(array{compressed_pair{0b10, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b00, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b10, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b11, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b00, 0}, compressed_pair{0b11, 0}}));
  }

  // mph::detail::as
  {
    using mph::utility::array;

    static_assert(int(0) == mph::detail::as<int>(array{0}));
    static_assert(int(1) == mph::detail::as<int>(array{1}));
    static_assert((int(1) << 0) + (int(2) << MPH_CHAR_BIT) == mph::detail::as<int>(array{1, 2}));
    static_assert((int(1) << 0) + (int(2) << MPH_CHAR_BIT)  + (int(3) << MPH_CHAR_BIT*2) == mph::detail::as<int>(array{1, 2, 3}));
  }

  // mph::detail::cmp
  {
    using mph::utility::array;

    static_assert(mph::detail::cmp(0, 0));
    static_assert(mph::detail::cmp(42u, 42u));
    static_assert(mph::detail::cmp(array{1, 2}, array{1, 2}));
    static_assert(not mph::detail::cmp(2, 1));
    static_assert(not mph::detail::cmp(42, 10));
    static_assert(not mph::detail::cmp(array{1}, array{1, 2}));
    static_assert(not mph::detail::cmp(array{1, 2}, array{2}));
    static_assert(not mph::detail::cmp(array{1, 2}, array{2, 1}));
  }

  // mph::detail::max_key_len
  {
    using mph::utility::array;
    using mph::utility::compressed_pair;
    using mph::fixed_string;

    static_assert(1u == mph::detail::max_key_len(array{compressed_pair{fixed_string{"a"}, 0}}));
    static_assert(2u == mph::detail::max_key_len(array{compressed_pair{fixed_string{"a"}, 0}, compressed_pair{fixed_string{"ab"}, 0}}));
    static_assert(3u == mph::detail::max_key_len(array{compressed_pair{fixed_string{"abc"}, 0}, compressed_pair{fixed_string{"ab"}, 0}}));
  }

  // mph::detail::size
  {
    using mph::utility::uint32_t;
    using mph::utility::uint64_t;
    using mph::utility::array;
    using mph::fixed_string;

    static_assert(sizeof(short) == mph::detail::size(short{}));
    static_assert(sizeof(uint32_t) == mph::detail::size(uint32_t{}));
    static_assert(sizeof(uint64_t) == mph::detail::size(uint64_t{}));
    static_assert(1u == mph::detail::size(array{'a'}));
    static_assert(2u == mph::detail::size(array{'a', 'b'}));
    static_assert(3u == mph::detail::size(array{'a', 'b', 'c'}));
    static_assert(3u == mph::detail::size(fixed_string{"abc"}));
  }

  // mph::hash
  {
    using mph::utility::uint32_t;
    using mph::utility::array;
    using mph::utility::compressed_pair;
    using mph::fixed_string;

    // integral
    {
      {
        constexpr array kv{
          compressed_pair{uint32_t(4), uint32_t(2)},
        };

        static_assert(0 == mph::hash<kv, 0>(uint32_t(0)));
        static_assert(0 == mph::hash<kv, 0>(uint32_t(1)));
        static_assert(2 == mph::hash<kv, 0>(uint32_t(4)));
      }

      {
        constexpr array kv{
          compressed_pair{uint32_t(4), uint32_t(2)},
          compressed_pair{uint32_t(42), uint32_t(87)},
          compressed_pair{uint32_t(100), uint32_t(100)},
        };

        static_assert(0 == mph::hash<kv, 0>(uint32_t(0)));
        static_assert(1 == mph::hash<kv, 1>(uint32_t(0)));
        static_assert(2 == mph::hash<kv, 0>(uint32_t(4)));
        static_assert(87 == mph::hash<kv, 0>(uint32_t(42)));
        static_assert(100 == mph::hash<kv, 0>(uint32_t(100)));
      }
    }

    // string-like
    {
      {
        enum class color { red = 1, green = 2, blue = 3 };

        constexpr array kv{
          compressed_pair{fixed_string{"red"}, color::red},
          compressed_pair{fixed_string{"green"}, color::green},
          compressed_pair{fixed_string{"blue"}, color::blue},
        };

        static_assert(color(-1) == mph::hash<kv, color(-1)>(fixed_string{"none"}));
        static_assert(color(0) == mph::hash<kv, color(0)>(fixed_string{"unknown"}));
        static_assert(color::red == mph::hash<kv, color(0)>(fixed_string{"red"}));
        static_assert(color::green == mph::hash<kv, color(0)>(fixed_string{"green"}));
        static_assert(color::blue == mph::hash<kv, color(0)>(fixed_string{"blue"}));
      }
    }
  }
}(), true));
#endif
#endif // MPH
