//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef MPH
#define MPH 2'2'1 // SemVer
#pragma GCC system_header

/**
 * [Minimal] Perfect hash library (https://github.com/boost-ext/mph)
 */
namespace mph::inline v2_2_1 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;

namespace utility {
template<class T1, class T2>
struct compressed_pair {
  using first_type = T1;
  using second_type = T2;
  [[no_unique_address]] T1 first;
  [[no_unique_address]] T2 second;
};
template<class T1, class T2> compressed_pair(T1, T2) -> compressed_pair<T1, T2>;

template<class T, u32 Size>
struct array {
  using value_type = T;
  [[nodiscard]] constexpr const T* data() const noexcept { return data_; }
  [[nodiscard]] constexpr T* data() noexcept { return data_; }
  [[nodiscard]] constexpr auto begin() const noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto begin() noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto end() const noexcept { return &data_[0] + Size; }
  [[nodiscard]] constexpr auto end() noexcept { return &data_[0] + Size; }
  [[nodiscard]] constexpr auto size() const noexcept { return Size; }
  [[nodiscard]] constexpr const auto& operator[](u32 i) const noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto& operator[](u32 i) noexcept { return data_[i]; }
  constexpr void fill(const T& value) noexcept { for (auto i = 0u; i < Size; ++i) { data_[i] = value; } }
  T data_[Size];
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;

template<class...> inline constexpr auto is_same_v = false;
template<class T>  inline constexpr auto is_same_v<T, T> = true;

namespace detail {
template <bool> struct conditional;
template <> struct conditional<false> { template <class, class T> using fn = T; };
template <> struct conditional<true>  { template <class T, class> using fn = T; };
}  // namespace detail
template <bool B, class T, class F>
using conditional_t = typename detail::conditional<B>::template fn<T, F>;

template<auto v> struct constant { static constexpr auto value = v; };
template<template<class R, auto Size> class R, class T, auto Size>
auto size(const R<T, Size>&) -> constant<Size>;

template<class T, u32 alignment>
struct aligned {
  using type = struct alignas(alignment) a  : T { };
  static_assert(alignment == alignof(type));
};
template<class T> struct aligned<T, 0u> { using type = T; };
template<class T, u32 alignment>
using aligned_t = typename aligned<T, alignment>::type;

template<class T, u32 width, u32 alignment = 1u>
using simd __attribute__ ((vector_size(width), aligned(alignment))) = T;

[[nodiscard]] constexpr auto clz(const u32 x) noexcept { return __builtin_clz(x); }
[[nodiscard]] constexpr auto clz(const u64 x) noexcept { return __builtin_clzl(x); }
[[nodiscard]] constexpr auto popcount(const u32 x) noexcept { return __builtin_popcountl(x); }
[[nodiscard]] constexpr auto popcount(const u64 x) noexcept { return __builtin_popcountll(x); }

#if defined(__BMI2__)
[[nodiscard]] [[gnu::always_inline]] inline auto bzhi(const u32 src, const u32 index) noexcept {
  return __builtin_ia32_bzhi_si(src, index);
}
[[nodiscard]] [[gnu::always_inline]] inline auto bzhi(const u64 src, const u64 index) noexcept {
  return __builtin_ia32_bzhi_di(src, index);
}
#else
template<class T>
[[nodiscard]] [[gnu::always_inline]] inline auto bzhi(const T src, const T index) noexcept {
  return src & ((T(1) << index) - T(1));
}
#endif

#if defined(__AVX2__)
[[nodiscard]] [[gnu::always_inline]] inline auto movmsk(const simd<u32, 256u / __CHAR_BIT__> x) noexcept {
  return __builtin_ia32_movmskps256(simd<float, 256u / __CHAR_BIT__>(x));
}
[[nodiscard]] [[gnu::always_inline]] inline auto movmsk(const simd<u64, 256u / __CHAR_BIT__> x) noexcept {
  return __builtin_ia32_movmskpd256(simd<double, 256u / __CHAR_BIT__>(x));
}
#endif

/// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
template<auto mask, class T, T size = sizeof(T) * __CHAR_BIT__>
[[nodiscard]] constexpr /*consteval*/ auto PEXT(const T a) noexcept -> T {
  T result{};
  T m = mask;
  auto k = 0u;
  for (T i{}; i < size; ++i) {
    if (m & 1) result |= ((a >> i) & 1) << k++;
    m >>= 1;
  }
  return result;
}

#if defined(__BMI2__)
template<auto mask>
[[nodiscard]] [[gnu::always_inline]] inline auto pext(const u64 a) noexcept -> u64 {
  return __builtin_ia32_pext_di(a, mask);
}
template<auto mask>
[[nodiscard]] [[gnu::always_inline]] inline auto pext(const u32 a) noexcept -> u32 {
  return __builtin_ia32_pext_si(a, mask);
}
#else
/// https://github.com/intel/compile-time-init-build/blob/main/include/lookup/pseudo_pext_lookup.hpp
template <auto mask, class T, T size = sizeof(T) * __CHAR_BIT__>
[[nodiscard]] [[gnu::always_inline]] inline auto pext(const T a) noexcept -> T {
  constexpr auto nbits = popcount(mask);
  constexpr auto cbits = (sizeof(T) * __CHAR_BIT__) - nbits - clz(mask);
  constexpr auto coefficient = [] {
    auto set = false;
    auto dst = cbits;
    T result{};
    for (auto i = 0u; i < size; ++i) {
      const auto curr = ((T(1) << i) & mask) != T();
      if (curr and not set) result = result | (T(1) << (dst - i));
      dst += curr;
      set = curr;
    }
    return result;
  }();
  return ((a & mask) * coefficient >> cbits) & ((T(1) << nbits) - T(1));
}
#endif

template<class T, u32 N, template<class, auto> class C, class _, auto Size>
[[nodiscard]] constexpr auto mask(const C<_, Size>& v) noexcept -> T {
  utility::array<T, Size> vs;
  T max{};
  for (auto i = 0u; i < Size; ++i) {
    if (vs[i] = v[i].first; vs[i] > max) {
      max = vs[i];
    }
  }
  constexpr auto H = (N * Size) << 1u;
  utility::array<utility::compressed_pair<bool, T>, H> hashed;
  const auto nbits = (sizeof(T) * __CHAR_BIT__) - clz(max) - 1u;
  T mask{(T(1) << nbits) - 1u};
  for (int i = nbits; i >= 0; --i) {
    mask &= ~(T(1) << i);
    hashed = {};
    for (auto j = 0u; j < Size; ++j) {
      const auto masked = vs[j] & mask;
      auto slot = masked % H;
      auto n = N - 1u;
      while (hashed[slot].first) {
        if (hashed[slot].second == masked and not n--) break;
        slot = (slot + 1u) % H;
      }
      if (hashed[slot].first and hashed[slot].second == masked) {
        mask |= (T(1) << i);
        break;
      }
      hashed[slot] = {true, masked};
    }
  }
  return mask;
}
} // namespace utility

template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const auto& data) noexcept -> T {
  if (__builtin_is_constant_evaluated()) {
    if constexpr (requires { data.data(); data.size(); }) {
      T t{};
      for (auto i = 0u; i < data.size(); ++i) {
        t = (t << __CHAR_BIT__) | data.data()[data.size() - i - 1u];
      }
      return t;
    } else if constexpr (requires { data[0]; }) {
      auto size = 0u;
      auto ptr = data;
      while (*ptr++) size++;
      T t{};
      for (auto i = 0u; i < size; ++i) {
        t = (t << __CHAR_BIT__) | data[size - i - 1u];
      }
      return t;
    } else {
      return data;
    }
  } else if constexpr (requires { data.data(); data.size(); }) {
    #if not defined(MPH_PAGE_SIZE)
    #define MPH_PAGE_SIZE 4096u // Used for string-like keys if
                                // the input string size is not
                                // known at compile-time
                                // If set to 0u __builtin_memcpy is used instead
    #endif
    if constexpr (requires { utility::size(data); }) {
      if constexpr (constexpr auto size = decltype(utility::size(data))::value; not size) {
        return T{};
      } else if constexpr (size == sizeof(T)) {
        return *__builtin_bit_cast(const T*, data.data());
      } else if constexpr (size <= sizeof(T)) {
        T t{};
        __builtin_memcpy(&t, data.data(), size);
        return t;
      }
    } else if constexpr (MPH_PAGE_SIZE) {
      // https://github.com/bminor/glibc/blob/master/sysdeps/generic/memcopy.h#L162
      if ((u64(data.data()) & (MPH_PAGE_SIZE - 1ul)) >= (MPH_PAGE_SIZE - sizeof(T))) [[unlikely]] { // page boundry
        return [&data] [[gnu::cold]] {
          T t{};
          __builtin_memcpy(&t, data.data(), data.size());
          return t;
        }();
      }
      T t;
      __builtin_memcpy(&t, data.data(), sizeof(t)); // not at page boundry
      return T(utility::bzhi(t, T(data.size() * __CHAR_BIT__)));
    } else {
      T t{};
      __builtin_memcpy(&t, data.data(), data.size());
      return t;
    }
  } else if constexpr (requires { T{data}; }) {
    return data;
  }
  return {};
}

template<auto kv>
struct config {
  // .0       - none of the input data can be found in the kv
  // (.0, .5) - input data is unlikely to be found in the kv
  // .5       - unpredictable (default)
  // (.5, 1.) - input data is likely to be found in the kv
  // 1.       - all input data can be found in the kv
  float probability{.5};

  // 1 - no collisions (deafult)
  // N - n collisions allowed
  u32 N{[] {
    using key_type = typename decltype(kv)::value_type::first_type;
    const auto bse = (1 << 14u);
    const auto max = 4u;
    const auto res = 1u << u32(kv.size() / (bse / sizeof(key_type)));
    return res > max ? max : res;
  }()};

  // 0 - no alignment
  // N - alignas(N) lookup table (N needs to be a power of 2)
  u32 alignment{};
};

/**
 * Perfect hash function
 *
 * @tparam kv constexpr array of key/value pairs
 * @tparam config configuration
 * @param key input data
 */
template<auto kv, auto cfg = config<kv>{}>
  requires (cfg.N >= 1u and cfg.probability >= .0f) and requires { kv.size(); kv.begin(); kv.end(); }
[[nodiscard]] constexpr auto hash(const auto& key) noexcept -> typename decltype(kv)::value_type::second_type {
  using key_type = typename decltype(kv)::value_type::first_type;
  using value_type = typename decltype(kv)::value_type::second_type;
  if constexpr (kv.size() == 0u or not cfg.probability) {
    return {};
  } else if (__builtin_is_constant_evaluated()) {
    constexpr auto to = [](const auto& data) -> decltype(auto) {
      if constexpr (requires { data.size(); }) {
        key_type result{};
        for (auto i = 0u; i < data.size(); ++i) {
          result = (result << __CHAR_BIT__) | data[data.size() - i - 1u];
        }
        return result;
      } else {
        return data;
      }
    };
    for (const auto& [k, v] : kv) {
      if (k == to(key)) {
        return v;
      }
    }
    return {};
  } else if constexpr (kv.size() == 1u) {
    return to<key_type>(key) == kv[0].first ? kv[0].second : value_type{};
  } else {
    return [&] {
      using mask_type = utility::conditional_t<sizeof(key_type) <= sizeof(u32), u32, u64>;
      static constexpr mask_type mask = utility::mask<key_type, cfg.N>(kv);
      static constexpr const auto lookup = [] {
        if constexpr (cfg.probability == 1.) {
          static_assert(cfg.N == 1u);
          utility::aligned_t<
            utility::array<
              value_type,
              mask_type(1) << utility::popcount(mask)
            >,
            cfg.alignment
          > lookup{};
          for (const auto& [key, value] : kv) {
            lookup[utility::PEXT<mask>(key)] = value;
          }
          return lookup;
        }
        else {
          #if defined (__AVX2__)
          utility::aligned_t<
            utility::array<
              utility::compressed_pair<
                utility::aligned_t<
                  utility::array<key_type, cfg.N>,
                  cfg.alignment
                >,
                utility::aligned_t<
                  utility::array<
                    value_type,
                    cfg.N == 1u ? 1u : 1u + (1u << (cfg.N - 1u))
                  >,
                  cfg.alignment
                >
              >,
              mask_type(1) << utility::popcount(mask)
            >,
            cfg.alignment
          > lookup{};
          for (const auto& [key, value] : kv) {
            if constexpr (auto& slot = lookup[utility::PEXT<mask>(key)]; cfg.N == 1u) {
              slot.first[0u] = key;
              slot.second[0u] = value;
            } else {
              auto n = 0u;
              while (slot.first[n]) n++;
              slot.first[n] = key;
              slot.second[1u << n] = value;
            }
          }
          return lookup;
          #else
          utility::aligned_t<
            utility::array<
              utility::aligned_t<
                utility::array<
                  utility::compressed_pair<key_type, value_type>,
                  cfg.N
                >,
                cfg.alignment
              >,
              mask_type(1) << utility::popcount(mask)
            >,
            cfg.alignment
          > lookup{};
          for (const auto& [key, value] : kv) {
            if constexpr (cfg.N == 1u) {
              lookup[utility::PEXT<mask>(key)][0u] = utility::compressed_pair{key, value};
            } else {
              auto& slot = lookup[utility::PEXT<mask>(key)];
              auto n = 0u;
              while (slot[n].first) n++;
              slot[n] = utility::compressed_pair{key, value};
            }
          }
          return lookup;
          #endif
        }
      }();

      auto&& lhs = to<key_type>(key);
      auto&& rhs = lookup[utility::pext<mask>(lhs)];

      constexpr auto cmp = [](bool cond) {
        #if defined(__clang__)
          if constexpr (cfg.probability == .5f) {
            return __builtin_unpredictable(cond);
          } else
        #endif
          return __builtin_expect_with_probability(cond, 1, cfg.probability);
      };

      if constexpr (cfg.N == 1u) {
        if constexpr (requires { rhs.first[0]; rhs.second[0]; }) {
          return cmp(lhs == rhs.first[0]) ? rhs.second[0] : value_type{};
        } else if constexpr (requires { rhs[0].first; rhs[0].second; }) {
          return cmp(lhs == rhs[0].first) ? rhs[0].second : value_type{};
        } else {
          return rhs;
        }
      }
      #if defined (__AVX2__)
      else if constexpr (constexpr auto width = 256u / __CHAR_BIT__;
        cfg.N * sizeof(key_type) <= width and (sizeof(key_type) == sizeof(u32) or
                                               sizeof(key_type) == sizeof(u64))) {
        return rhs.second[utility::movmsk(
          utility::simd<key_type, width>(
            to<key_type>(key)
            ==
            *(utility::simd<key_type, width>*)(rhs.first.data())
          )
        )];
      }
      #endif
      else {
        for (auto i = 0u; i < rhs.size(); ++i) {
          if (cmp(lhs == rhs[i].first)) {
            return rhs[i].second;
          }
        }
      }
      return value_type{};
    }();
  }
}
} // namespace mph

#if not defined(DISABLE_STATIC_ASSERT_TESTS)
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // mph::utility::compressed_pair
  {
    static_assert(1 == mph::utility::compressed_pair{1, 2}.first);
    static_assert(2 == mph::utility::compressed_pair{1, 2}.second);
    static_assert(sizeof(int) + sizeof(int) == sizeof(mph::utility::compressed_pair{int{}, int{}}));
    struct empty { };
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{empty{}, 42}));
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{42, empty{}}));
    static_assert(sizeof(empty) + sizeof(empty) == sizeof(mph::utility::compressed_pair{empty{}, empty{}}));
  }

  // mph::utility::array
  {
    {
      mph::utility::array<mph::u32, 1> a{};
      expect(1 == a.size());
    }

    {
      mph::utility::array a{1, 2};
      expect(2u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
    }

    {
      mph::utility::array a{1};
      a[0] = 2;
      expect(2 == a[0]);
    }

    {
      mph::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(a.begin() != a.end());
      expect(a.size() == mph::u32(a.end() - a.begin()));
      expect(a.end() == a.begin() + a.size());
    }
  }

  // mp::utility::is_same_v
  {
    static_assert(mph::utility::is_same_v<void, void>);
    static_assert(mph::utility::is_same_v<int, int>);
    static_assert(not mph::utility::is_same_v<int, void>);
    static_assert(not mph::utility::is_same_v<void, int>);
    static_assert(not mph::utility::is_same_v<void*, int>);
    static_assert(not mph::utility::is_same_v<int, const int>);
  }

  // mph::utility::conditional_t
  {
    static_assert(mph::utility::is_same_v<void, mph::utility::conditional_t<true, void, int>>);
    static_assert(mph::utility::is_same_v<int, mph::utility::conditional_t<false, void, int>>);
  }

  // mph::utility::constant
  {
    static_assert(0 == mph::utility::constant<0>::value);
    static_assert(42u == mph::utility::constant<42u>::value);
    static_assert('X' == mph::utility::constant<'X'>::value);

  }

  // mph::utility::size
  {
    using mph::utility::array;
    static_assert(1 == decltype(mph::utility::size(array<bool, 1>{}))::value);
    static_assert(42 == decltype(mph::utility::size(array<int, 42>{}))::value);
  }

  // mph::utility::aligned_t
  {
    using mph::utility::array;

    static_assert(16u == alignof(mph::utility::aligned_t<array<int, 42>, 16u>));
    static_assert(32u == alignof(mph::utility::aligned_t<array<int, 42>, 32u>));
    static_assert(64u == alignof(mph::utility::aligned_t<array<int, 42>, 64u>));
    static_assert(alignof(int) == alignof(mph::utility::aligned_t<array<int, 42>, 0u>));
  }

  // mph::utility::pext
  {
    static_assert(0    == mph::utility::PEXT<0b00>(0b00));
    static_assert(0    == mph::utility::PEXT<0b00>(0b01));
    static_assert(0b1  == mph::utility::PEXT<0b01>(0b01));
    static_assert(0b01 == mph::utility::PEXT<0b11>(0b01));
    static_assert(0b0  == mph::utility::PEXT<0b10>(0b01));
    static_assert(0b1  == mph::utility::PEXT<0b10>(0b11));
    static_assert(0b1  == mph::utility::PEXT<0b01>(0b11));
    static_assert(0b11 == mph::utility::PEXT<0b11>(0b11));
  }

  // mph::utility::mask
  {
    using mph::u32;
    using mph::utility::array;
    using mph::utility::compressed_pair;

    static_assert(0b10 == mph::utility::mask<u32, 1u>(array{compressed_pair{0b10, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::utility::mask<u32, 1u>(array{compressed_pair{0b00, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::utility::mask<u32, 1u>(array{compressed_pair{0b10, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::utility::mask<u32, 1u>(array{compressed_pair{0b11, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::utility::mask<u32, 1u>(array{compressed_pair{0b00, 0}, compressed_pair{0b11, 0}}));
  }

  // mph::to
  {
    using mph::u32;
    using mph::utility::array;

    static_assert(0 == mph::to<u32>(0));
    static_assert(42 == mph::to<u32>(42));
    static_assert(42u == mph::to<u32>(42u));
    static_assert(0 == mph::to<u32>(""));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) == mph::to<u32>("AB"));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) + (u32('C') << __CHAR_BIT__*2) == mph::to<u32>("ABC"));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) == mph::to<u32>(array{'A','B'}));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) + (u32('C') << __CHAR_BIT__*2) == mph::to<u32>(array{'A','B','C'}));
  }

  // mph::hash
  {
    using mph::u32;
    using mph::utility::compressed_pair;
    using mph::utility::array;

    // integral
    {
      {
        constexpr array kv{
          compressed_pair{u32(4), u32(2)},
        };

        static_assert(0 == mph::hash<kv>(u32(0)));
        static_assert(0 == mph::hash<kv>(u32(1)));
        static_assert(2 == mph::hash<kv>(u32(4)));
      }

      {
        constexpr array kv{
          compressed_pair{u32(4), u32(2)},
          compressed_pair{u32(42), u32(87)},
          compressed_pair{u32(100), u32(100)},
        };

        static_assert(0 == mph::hash<kv>(u32(0)));
        static_assert(2 == mph::hash<kv>(u32(4)));
        static_assert(87 == mph::hash<kv>(u32(42)));
        static_assert(100 == mph::hash<kv>(u32(100)));
      }
    }

    // string-like
    {
      {
        constexpr array kv{
          compressed_pair{mph::to<u32>("BTC"), 1},
          compressed_pair{mph::to<u32>("ETH"), 2},
          compressed_pair{mph::to<u32>("XRP"), 3},
        };

        static_assert(0 == mph::hash<kv>(mph::to<u32>("")));
        static_assert(1 == mph::hash<kv>(mph::to<u32>("BTC")));
        static_assert(2 == mph::hash<kv>(mph::to<u32>("ETH")));
        static_assert(3 == mph::hash<kv>(mph::to<u32>("XRP")));
      }
    }
  }
}(), true));
#endif
#endif // MPH
