//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef MPH
#define MPH 2'2'1 // SemVer

/**
 * Perfect hash library (https://github.com/boost-ext/mph)
 */
namespace mph::inline v2_2_1 {
using size_t = __SIZE_TYPE__;
using uint8_t = __UINT8_TYPE__;
using uint16_t = __UINT16_TYPE__;
using uint32_t = __UINT32_TYPE__;
using uint64_t = __UINT64_TYPE__;
namespace utility {
template<class T1, class T2>
struct compressed_pair {
  using first_type = T1;
  using second_type = T2;
  [[no_unique_address]] T1 first;
  [[no_unique_address]] T2 second;
};
template<class T1, class T2> compressed_pair(T1, T2) -> compressed_pair<T1, T2>;

template<class T, size_t Size>
struct array {
  using value_type = T;
  [[nodiscard]] constexpr const T* data() const noexcept { return data_; }
  [[nodiscard]] constexpr T* data() noexcept { return data_; }
  [[nodiscard]] constexpr auto begin() const noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto begin() noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto end() const noexcept { return &data_[0] + Size; }
  [[nodiscard]] constexpr auto end() noexcept { return &data_[0] + Size; }
  [[nodiscard]] constexpr auto size() const noexcept { return Size; }
  [[nodiscard]] constexpr const auto& operator[](size_t i) const noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto& operator[](size_t i) noexcept { return data_[i]; }
  constexpr void fill(const T& value) noexcept { for (auto i = 0u; i < Size; ++i) { data_[i] = value; } }
  T data_[Size];
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;

template<class T, size_t Size>
struct static_vector {
  using value_type = T;
  constexpr auto push_back(const T& value) noexcept { data_[size_++] = value; }
  [[nodiscard]] constexpr auto begin() const noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto begin() noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto end() const noexcept { return &data_[0] + size_; }
  [[nodiscard]] constexpr auto end() noexcept { return &data_[0] + size_; }
  [[nodiscard]] constexpr auto operator[](size_t i) const noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto& operator[](size_t i) noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto size() const noexcept { return size_; }
  [[nodiscard]] constexpr auto capacity() const noexcept { return Size; }
  union { T data_[Size]{}; }; // !trivial union
  size_t size_{};
};

template<class...> inline constexpr auto is_same_v = false;
template<class T>  inline constexpr auto is_same_v<T, T> = true;

namespace detail {
template <bool> struct conditional;
template <> struct conditional<false> { template <class, class T> using fn = T; };
template <> struct conditional<true>  { template <class T, class> using fn = T; };
}  // namespace detail
template <bool B, class T, class F>
using conditional_t = typename detail::conditional<B>::template fn<T, F>;

template<class T, size_t alignment>
struct aligned {
  using type = struct alignas(alignment) a  : T { };
  static_assert(alignment == alignof(type));
};
template<class T> struct aligned<T, 0u> { using type = T; };
template<class T, size_t alignment>
using aligned_t = typename aligned<T, alignment>::type;
} // namespace utility

namespace detail {
/// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
template<class T, T size = sizeof(T) * __CHAR_BIT__>
[[nodiscard]] constexpr auto pext(const T a, T mask) noexcept {
  T result{};
  auto k = 0u;
  for (T i{}; i < size; ++i) {
    if (mask & 1) result |= ((a >> i) & 1) << k++;
    mask >>= 1;
  }
  return result;
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto pext(const uint32_t a, const uint32_t mask) noexcept {
  return __builtin_ia32_pext_si(a, mask);
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto pext(const uint64_t a, const uint64_t mask) noexcept {
  return __builtin_ia32_pext_di(a, mask);
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto bzhi(const uint32_t src, const uint32_t index) noexcept {
  return __builtin_ia32_bzhi_si(src, index);
}

[[nodiscard]] [[gnu::target("bmi2")]] [[gnu::always_inline]]
inline auto bzhi(const uint64_t src, const uint64_t index) noexcept {
  return __builtin_ia32_bzhi_di(src, index);
}

[[nodiscard]] constexpr auto clz(const uint32_t x) { return __builtin_clz(x); }
[[nodiscard]] constexpr auto clz(const uint64_t x) { return __builtin_clzl(x); }

template<class T, template<class, auto> class C, class _, auto Size, auto size = sizeof(T) * __CHAR_BIT__>
[[nodiscard]] constexpr auto mask(const C<_, Size>& v) noexcept -> T {
  utility::array<T, Size> vs;
  T max{};
  for (auto i = 0u; i < v.size(); ++i) {
    if (vs[i] = v[i].first; vs[i] > max) {
      max = vs[i];
    }
  }
  constexpr auto N = Size << 1u;
  utility::array<utility::compressed_pair<bool, T>, N> hashed;
  const auto nbits = size - clz(max) - 1;
  T mask{(T(1) << nbits) - 1};
  for (int n = nbits; n >= 0; --n) {
    mask &= ~(T(1) << n);
    hashed = {};
    for (auto i = 0u; i < v.size(); ++i) {
      const auto masked = vs[i] & mask;
      auto hash = masked % N;
      while (hashed[hash].first and hashed[hash].second != masked) {
        hash = (hash + 1u) % N;
      }
      if (hashed[hash].first and hashed[hash].second == masked) {
        mask |= (T(1) << n);
        break;
      }
      hashed[hash] = {true, masked};
    }
  }
  return mask;
}
} // namespace detail

template<class T, class C, size_t Size>
  requires (sizeof(C) == sizeof(uint8_t))
[[nodiscard]] constexpr auto to(const C (&data)[Size]) noexcept {
  T result{};
  constexpr auto size = Size - 1u; // no null terminated
  for (auto i = 0u; i < size; ++i) {
    result = (result << __CHAR_BIT__) | data[size - i - 1u];
  }
  return result;
}

template<class T> [[nodiscard]] constexpr auto to(const T& value) noexcept -> const T& {
  return value;
}

template<class T, template<class, auto> class R, class _, auto Size>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const R<_, Size>& data) noexcept -> T
  requires requires { data.data(); } {
  if constexpr (not Size) {
    return T{};
  } else if constexpr (Size == sizeof(T)) {
    return *__builtin_bit_cast(const T*, data.data());
  } else if constexpr (Size <= sizeof(T)) {
    T t{};
    __builtin_memcpy(&t, data.data(), Size);
    return t;
  }
}

template<class T, class cold>
[[nodiscard]] [[gnu::cold]] constexpr auto to(const auto& data) noexcept -> T
  requires requires { data.data(); data.size(); } {
  T t{};
  __builtin_memcpy(&t, data.data(), data.size());
  return t;
}

template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const auto& data) noexcept -> T
  requires requires { data.data(); data.size(); } {
  #if not defined(MPH_PAGE_SIZE)
  #define MPH_PAGE_SIZE 4096u // Used for string-like keys if
                              // the input string size is not
                              // known at compile-time
                              // If set to 0u __builtin_memcpy is used instead
  #endif

  if constexpr (MPH_PAGE_SIZE) {
    // https://github.com/bminor/glibc/blob/master/sysdeps/generic/memcopy.h#L162
    if ((uint64_t(data.data()) & (MPH_PAGE_SIZE - 1ul)) >= (MPH_PAGE_SIZE - sizeof(T))) [[unlikely]] { // page boundry
      return to<T, class cold>(data);
    }
    T t{};
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    __builtin_memcpy(&t, data.data(), sizeof(T)); // not at page boundry
    #pragma GCC diagnostic pop

    if constexpr (sizeof(T) == sizeof(uint32_t)) {
      return T(detail::bzhi(t, T(data.size() * __CHAR_BIT__)));
    } else if constexpr (sizeof(T) == sizeof(uint64_t)) {
      return T(detail::bzhi(t, T(data.size() * __CHAR_BIT__)));
    }
    return t;
  } else {
    T t{};
    __builtin_memcpy(&t, data.data(), data.size());
    return t;
  }
}

inline constexpr auto unconditional =
  []([[maybe_unused]] const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) noexcept {
    return lhs; // [unsafe] returns unconditionally
  };

inline constexpr auto conditional =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    return cond ? lhs : rhs; // generates jmp (x86-64)
  };

inline constexpr auto likely =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    if (cond) [[likely]] {
      return lhs;
    } else {
      return rhs;
    }
  };

inline constexpr auto unlikely =
  [](const bool cond, const auto lhs, const auto rhs) {
    if (cond) [[unlikely]] {
      return lhs;
    } else {
      return rhs;
    }
  };

template<auto Probablity>
inline constexpr auto conditional_probability =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    if (__builtin_expect_with_probability(cond, 1, Probablity)) {
      return lhs;
    } else {
      return rhs;
    }
  };

inline constexpr auto branchless =
  [](const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) noexcept {
    return cond * lhs; // more likely to generate cmov (x86-64)
  };

inline constexpr auto unpredictable =
  [](const bool cond, const auto lhs, const auto rhs) noexcept {
    #if defined(__clang__)
    if (__builtin_unpredictable(cond)) { // generates cmov (x86-64)
    #else
    if (__builtin_expect_with_probability(cond, 1, .5)) {
    #endif
      return lhs;
    } else {
      return rhs;
    }
  };

template<
  auto cmp = conditional,
  size_t alignment = size_t{}
> inline constexpr auto direct = []<auto kv, auto unknown>(const auto& key) -> decltype(auto) {
  using key_type = typename decltype(kv)::value_type::first_type;
  using value_type = typename decltype(kv)::value_type::second_type;
  using mask_type = utility::conditional_t<sizeof(key_type) <= sizeof(uint32_t), uint32_t, uint64_t>;
  static constexpr mask_type mask = detail::mask<key_type>(kv);
  static constexpr const auto lookup = [] {
    utility::aligned_t<
      utility::array<
        utility::compressed_pair<key_type, value_type>,
        (mask_type(1) << __builtin_popcountll(mask))
      >, alignment
    > lookup{};
    if constexpr (unknown != decltype(unknown){}) {
      lookup.fill(utility::compressed_pair{key_type{}, unknown});
    }
    for (const auto& [key, value] : kv) {
      lookup[detail::pext<key_type>(key, mask)] = utility::compressed_pair{key, value};
    }
    return lookup;
  }();

  auto&& lhs = to<key_type>(key);
  auto&& [rhs, value] = lookup[detail::pext(lhs, mask)];
  return cmp(lhs == rhs, value, unknown);
};

template<
  auto cmp = conditional,
  size_t alignment = size_t{}
> inline constexpr auto indirect = []<auto kv, auto unknown>(const auto& key) -> decltype(auto) {
  using key_type = typename decltype(kv)::value_type::first_type;
  using value_type = typename decltype(kv)::value_type::second_type;
  using mask_type = utility::conditional_t<sizeof(key_type) <= sizeof(uint32_t), uint32_t, uint64_t>;
  static constexpr mask_type mask = detail::mask<key_type>(kv);
  static constexpr const auto storage = [] {
    utility::aligned_t<
      utility::array<
        utility::compressed_pair<key_type, value_type>,
        kv.size()
      >, alignment
    > storage;
    for (auto i = 0u; const auto& [key, value] : kv) {
      storage[i++] = utility::compressed_pair{key, value};
    }
    return storage;
  }();
  static constexpr const auto lookup = [] {
    constexpr auto nbits = __builtin_popcountll(mask);
    using type = utility::conditional_t<
      (nbits <= __CHAR_BIT__),
      uint8_t,
      utility::conditional_t<
        nbits <= (sizeof(uint16_t) * __CHAR_BIT__),
        uint16_t,
        uint32_t
      >
    >;
    utility::aligned_t<
      utility::array<
        type,
        (mask_type(1) << nbits)
      >, alignment
    > lookup{};
    for (type i{}; const auto& [key, value] : kv) {
      lookup[detail::pext<key_type>(key, mask)] = i++;
    }
    return lookup;
  }();

  auto&& lhs = to<key_type>(key);
  auto&& [rhs, value] = storage[size_t(lookup[detail::pext(lhs, mask)])];
  return cmp(lhs == rhs, value, unknown);
};

template<
  auto cmp = conditional,
  size_t alignment = size_t{},
  auto split_mask = 0xFF
> inline constexpr auto split = []<auto kv, auto unknown>(const auto& key) -> decltype(auto)
    requires requires { key[0]; } {
  using key_type = typename decltype(kv)::value_type::first_type;
  using value_type = typename decltype(kv)::value_type::second_type;
  using mask_type = utility::conditional_t<sizeof(key_type) <= sizeof(uint32_t), uint32_t, uint64_t>;
  static constexpr auto splits = [] {
    utility::array<
      utility::static_vector<
        utility::compressed_pair<key_type, value_type>,
        kv.size()
      >, (1u << __CHAR_BIT__)
    > splits{};
    for (const auto& [key, value] : kv) {
      splits[key & key_type(split_mask)].push_back(utility::compressed_pair{key, value});
    }
    return splits;
  }();
  static constexpr const auto masks = [] {
    utility::aligned_t<
      utility::array<
        mask_type,
        (1u << __CHAR_BIT__)
      >, alignment
    > masks{};
    for (auto i = 0u; i < splits.size(); ++i) {
      if (splits[i].size()) {
        masks[i] = detail::mask<key_type>(splits[i]);
      }
    }
    return masks;
  }();
  static constexpr auto max = [] {
    mask_type max{};
    for (const auto& mask : masks) {
      if (const mask_type v = __builtin_popcountll(mask); v > max) { max = v; }
    }
    return max;
  }();
  static constexpr const auto lookups = [] {
    utility::aligned_t<
      utility::array<
        utility::array<
          utility::compressed_pair<key_type, value_type>,
          (mask_type(1) << max)
        >, (1u << __CHAR_BIT__)
      >, alignment
    > lookups{};
    for (auto i = 0u; i < lookups.size(); ++i) {
      auto& lookup = lookups[i];
      const auto& mask = masks[i];
      const auto& split = splits[i];
      if constexpr (unknown != decltype(unknown){}) {
        lookup.fill(utility::compressed_pair{key_type{}, unknown});
      }
      for (const auto& [key, value] : split) {
        lookup[detail::pext<key_type>(key, mask)] = utility::compressed_pair{key, value};
      }
    }
    return lookups;
  }();

  const auto k = key[0];
  const auto mask = masks[k];
  auto&& lhs = to<key_type>(key);
  auto&& [rhs, value] = lookups[k][detail::pext(lhs, mask)];
  return cmp(lhs == rhs, value, unknown);
};

template<
  auto kv,
  typename decltype(kv)::value_type::second_type unknown =
    typename decltype(kv)::value_type::second_type{},
  auto policy = direct<>
> requires requires {
    kv.size();
    kv.begin();
    kv.end();
    kv[0].first;
    kv[0].second;
} [[nodiscard]] constexpr auto hash(const auto& key) noexcept -> decltype(unknown) {
  using key_type = typename decltype(kv)::value_type::first_type;
  if (__builtin_is_constant_evaluated()) {
    constexpr auto to = [](const auto& data) -> decltype(auto) {
      if constexpr (requires { data.size(); }) {
        key_type result{};
        for (auto i = 0u; i < data.size(); ++i) {
          result = (result << __CHAR_BIT__) | data[data.size() - i - 1u];
        }
        return result;
      } else {
        return data;
      }
    };
    for (const auto& [k, v] : kv) {
      if (k == to(key)) {
        return v;
      }
    }
    return unknown;
  } else if constexpr (kv.size() == 0u) {
    return unknown;
  } else if constexpr (kv.size() == 1u) {
    return to<key_type>(key) == kv[0].first ? kv[0].second : unknown;
  } else {
    return policy.template operator()<kv, unknown>(key);
  }
}
} // namespace mph

#if not defined(DISABLE_STATIC_ASSERT_TESTS)
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // mph::utility::compressed_pair
  {
    static_assert(1 == mph::utility::compressed_pair{1, 2}.first);
    static_assert(2 == mph::utility::compressed_pair{1, 2}.second);
    static_assert(sizeof(int) + sizeof(int) == sizeof(mph::utility::compressed_pair{int{}, int{}}));
    struct empty { };
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{empty{}, 42}));
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{42, empty{}}));
    static_assert(sizeof(empty) + sizeof(empty) == sizeof(mph::utility::compressed_pair{empty{}, empty{}}));
  }

  // mph::utility::array
  {
    {
      mph::utility::array<mph::size_t, 1> a{};
      expect(1 == a.size());
    }

    {
      mph::utility::array a{1, 2};
      expect(2u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
    }

    {
      mph::utility::array a{1};
      a[0] = 2;
      expect(2 == a[0]);
    }

    {
      mph::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(a.begin() != a.end());
      expect(a.size() == mph::size_t(a.end() - a.begin()));
      expect(a.end() == a.begin() + a.size());
    }
  }

  // mph::utility::static_vector
  {
    using mph::size_t;

    {
      mph::utility::static_vector<size_t, 1> v{};
      expect(0u == v.size());
      expect(1 == v.capacity());
    }

    {
      mph::utility::static_vector<int, 2> v;
      expect(0u == v.size());
      expect(2 == v.capacity());

      v.push_back(1);
      expect(1u == v.size());
      expect(1 == v[0]);

      v.push_back(2);
      expect(2u == v.size());
      expect(2 == v[1]);
    }

    {
      mph::utility::static_vector<int, 42> v{};
      expect(0u == v.size() && 0u == size_t(v.end() - v.begin()));
      expect(v.begin() == v.end());

      v.push_back(1);
      expect(1u == v.size() && 1 == size_t(v.end() - v.begin()));
      expect(v.begin() != v.end());

      v.push_back(2);
      expect(2u == v.size() && 2u == size_t(v.end() - v.begin()));
      expect(v.begin() != v.end());
    }
  }

  // mp::utility::is_same_v
  {
    static_assert(mph::utility::is_same_v<void, void>);
    static_assert(mph::utility::is_same_v<int, int>);
    static_assert(not mph::utility::is_same_v<int, void>);
    static_assert(not mph::utility::is_same_v<void, int>);
    static_assert(not mph::utility::is_same_v<void*, int>);
    static_assert(not mph::utility::is_same_v<int, const int>);
  }

  // mph::utility::conditional_t
  {
    static_assert(mph::utility::is_same_v<void, mph::utility::conditional_t<true, void, int>>);
    static_assert(mph::utility::is_same_v<int, mph::utility::conditional_t<false, void, int>>);
  }

  // mph::utility::aligned_t
  {
    using mph::utility::array;

    static_assert(16u == alignof(mph::utility::aligned_t<array<int, 42>, 16u>));
    static_assert(32u == alignof(mph::utility::aligned_t<array<int, 42>, 32u>));
    static_assert(64u == alignof(mph::utility::aligned_t<array<int, 42>, 64u>));
    static_assert(alignof(int) == alignof(mph::utility::aligned_t<array<int, 42>, 0u>));
  }

  // mph::policies
  {
    static_assert(1 == mph::unconditional(true, 1, 2));
    static_assert(1 == mph::unconditional(false, 1, 2));

    static_assert(1 == mph::conditional(true, 1, 2));
    static_assert(2 == mph::conditional(false, 1, 2));

    static_assert(1 == mph::likely(true, 1, 2));
    static_assert(2 == mph::likely(false, 1, 2));

    static_assert(1 == mph::unlikely(true, 1, 2));
    static_assert(2 == mph::unlikely(false, 1, 2));

    static_assert(1 == mph::conditional_probability<1>(true, 1, 2));
    static_assert(2 == mph::conditional_probability<1>(false, 1, 2));

    static_assert(1 == mph::branchless(true, 1, 2));
    static_assert(0 == mph::branchless(false, 1, 2));
  }

  // mph::detail::pext
  {
    static_assert(0    == mph::detail::pext(0b00, 0b00));
    static_assert(0    == mph::detail::pext(0b01, 0b00));
    static_assert(0b1  == mph::detail::pext(0b01, 0b01));
    static_assert(0b01 == mph::detail::pext(0b01, 0b11));
    static_assert(0b0  == mph::detail::pext(0b01, 0b10));
    static_assert(0b1  == mph::detail::pext(0b11, 0b10));
    static_assert(0b1  == mph::detail::pext(0b11, 0b01));
    static_assert(0b11 == mph::detail::pext(0b11, 0b11));
  }

  // mph::detail::mask
  {
    using mph::uint32_t;
    using mph::utility::array;
    using mph::utility::compressed_pair;

    static_assert(0b10 == mph::detail::mask<uint32_t>(array{compressed_pair{0b10, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b00, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b10, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b11, 0}, compressed_pair{0b00, 0}}));
    static_assert(0b01 == mph::detail::mask<uint32_t>(array{compressed_pair{0b00, 0}, compressed_pair{0b11, 0}}));
  }

  // mph::to
  {
    static_assert(0 == mph::to<int>(""));
    static_assert((int('A') << 0) + (int('B') << __CHAR_BIT__) == mph::to<int>("AB"));
    static_assert((int('A') << 0) + (int('B') << __CHAR_BIT__) + (int('C') << __CHAR_BIT__*2) == mph::to<int>("ABC"));
  }

  // mph::hash
  {
    using mph::uint32_t;
    using mph::utility::compressed_pair;
    using mph::utility::array;

    // integral
    {
      {
        constexpr array kv{
          compressed_pair{uint32_t(4), uint32_t(2)},
        };

        static_assert(0 == mph::hash<kv, 0>(uint32_t(0)));
        static_assert(0 == mph::hash<kv, 0>(uint32_t(1)));
        static_assert(2 == mph::hash<kv, 0>(uint32_t(4)));
      }

      {
        constexpr array kv{
          compressed_pair{uint32_t(4), uint32_t(2)},
          compressed_pair{uint32_t(42), uint32_t(87)},
          compressed_pair{uint32_t(100), uint32_t(100)},
        };

        static_assert(0 == mph::hash<kv, 0>(uint32_t(0)));
        static_assert(1 == mph::hash<kv, 1>(uint32_t(0)));
        static_assert(2 == mph::hash<kv, 0>(uint32_t(4)));
        static_assert(87 == mph::hash<kv, 0>(uint32_t(42)));
        static_assert(100 == mph::hash<kv, 0>(uint32_t(100)));
      }
    }

    // string-like
    {
      {
        constexpr array kv{
          compressed_pair{mph::to<uint32_t>("BTC"), 1},
          compressed_pair{mph::to<uint32_t>("ETH"), 2},
          compressed_pair{mph::to<uint32_t>("XRP"), 3},
        };

        static_assert(0 == mph::hash<kv>(mph::to<uint32_t>("")));
        static_assert(-1 == mph::hash<kv, -1>(mph::to<uint32_t>("")));
        static_assert(1 == mph::hash<kv, -1>(mph::to<uint32_t>("BTC")));
        static_assert(2 == mph::hash<kv, -1>(mph::to<uint32_t>("ETH")));
        static_assert(3 == mph::hash<kv, -1>(mph::to<uint32_t>("XRP")));
      }
    }
  }
}(), true));
#endif
#endif // MPH
