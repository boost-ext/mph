//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef MPH
#define MPH 2'0'0 // SemVer - should match mph namespace

#if __has_include(<x86intrin.h>)
#include <x86intrin.h>
#endif

#include <bit>
#include <array>
#include <type_traits>
#include <cstdint>
#include <utility>
#include <climits>

#if not defined(MPH_PAGE_SIZE)
#define MPH_PAGE_SIZE 4096u // only used for string-like keys / if set to 0 unsafe memcpy is disabled
#endif

#if not defined(MPH_FIXED_STRING_MAX_SIZE)
#define MPH_FIXED_STRING_MAX_SIZE 8u // only used for string-like keys
#endif

/**
 * Perfect hash function library (https://en.wikipedia.org/wiki/Perfect_hash_function)
 */
namespace mph::inline v2_0_0 {
namespace utility {
template<class T, template<class, auto> class R, class _, auto Size>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const R<_, Size>& data) -> T {
  if constexpr (not Size) {
    return T{};
  } else if constexpr (Size == sizeof(T)) {
    return *__builtin_bit_cast(const T*, data.data());
  } else {
    static_assert(Size <= sizeof(T));
    T t{};
    __builtin_memcpy(&t, data.data(), Size);
    return t;
  }
}

template<class T, class cold>
[[nodiscard]] [[gnu::cold]] constexpr auto to(const auto& data) -> T {
  T t{};
  __builtin_memcpy(&t, data.data(), data.size());
  return t;
}

template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const auto& data) -> T {
  if constexpr (MPH_PAGE_SIZE) {
    // https://github.com/bminor/glibc/blob/master/sysdeps/generic/memcopy.h#L162
    if ((std::uint64_t(data.data()) & (MPH_PAGE_SIZE - 1ul)) >= (MPH_PAGE_SIZE - sizeof(T))) [[unlikely]] { // page boundry
      return to<T, class cold>(data);
    }
    T t{};
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    __builtin_memcpy(&t, data.data(), sizeof(T)); // not at page boundry
    #pragma GCC diagnostic pop

    if constexpr (sizeof(T) == sizeof(std::uint32_t)) {
      return T(_bzhi_u32(t, data.size() * CHAR_BIT));
    } else if constexpr (sizeof(T) == sizeof(std::uint64_t)) {
      return T(_bzhi_u64(t, data.size() * CHAR_BIT));
    }
    return t;
  } else {
    T t{};
    __builtin_memcpy(&t, data.data(), data.size());
    return t;
  }
}

template<class T>
[[nodiscard]] constexpr auto as(auto&& value) -> T requires requires { value.size(); } {
  T result{};
  const auto size = value.size();
  for (auto i = 0u; i < size; ++i) {
    result = (result << CHAR_BIT) | value[size-i-1];
  }
  return result;
}

template<class T>
[[nodiscard]] constexpr auto as(const T value) -> T {
  return value;
}

template<class T> // https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
[[nodiscard]] constexpr auto pext(const T a, T mask) {
  T result{};
  auto k = 0u;
  constexpr auto size = sizeof(T) * CHAR_BIT;
  for (auto i = T(); i < T(size); ++i) {
    if (mask & 1) result |= ((a >> i) & 1) << k++;
    mask >>= 1;
  }
  return result;
}

[[nodiscard]] [[gnu::target("bmi2")]] inline auto pext(const std::uint32_t a, const std::uint32_t mask) {
  return _pext_u32(a, mask);
}

[[nodiscard]] [[gnu::target("bmi2")]] inline auto pext(const std::uint64_t a, const std::uint64_t mask) {
  return _pext_u64(a, mask);
}

template<class T, auto Size>
[[nodiscard]] constexpr auto unique(const std::array<T, Size>& v) -> bool {
  for (auto i = 0u; i < Size; ++i) {
    for (auto j = i+1; j < Size; ++j) {
      if (v[i] == v[j]) {
        return false;
      }
    }
  }
  return true;
}

template<class T, class TPair, auto Size>
[[nodiscard]] constexpr auto pext_mask(const std::array<TPair, Size>& kv) -> T {
  std::array<T, Size> masked;
  T mask{~T{}};
  constexpr auto size = sizeof(T) * CHAR_BIT;
  for (int n = size-1; n >= 0; --n) {
    mask &= ~(T(1) << n);

    for (auto i = 0u; i < Size; ++i) {
      masked[i] = pext<T>(as<T>(kv[i].first), mask);
    }

    if (not unique(masked)) {
      mask |= (T(1) << n);
    }
  }
  return mask;
}
}  // namespace utility

template<class T, auto MaxSize> struct basic_fixed_string final {
  constexpr basic_fixed_string() = default;
  template<auto Size>
  constexpr explicit(false) basic_fixed_string(const T (&input)[Size]) requires (Size-1 <= MaxSize) : size_{Size-1} {
    for (auto i = 0u; i < Size-1; ++i) { data_[i] = input[i]; } // no null terminated
  }
  [[nodiscard]] constexpr auto data() const { return data_.data(); }
  [[nodiscard]] constexpr auto size() const { return size_; }
  [[nodiscard]] constexpr auto operator[](const auto i) const { return data_[i]; }
  [[nodiscard]] constexpr auto operator<=>(const basic_fixed_string&) const = default;

  decltype(MaxSize) size_{};
  std::array<T, MaxSize> data_{};
};

using fixed_string = basic_fixed_string<char, MPH_FIXED_STRING_MAX_SIZE>;

inline constexpr auto unconditional = []([[maybe_unused]] const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) {
  return lhs; // [unsafe] returns unconditionally
};

inline constexpr auto conditional = [](const bool cond, const auto lhs, const auto rhs) {
  return cond ? lhs : rhs; // generates jmp (x86-64)
};

inline constexpr auto likely = [](const bool cond, const auto lhs, const auto rhs) {
  if (cond) [[likely]] {
    return lhs;
  } else {
    return rhs;
  }
};

inline constexpr auto unlikely = [](const bool cond, const auto lhs, const auto rhs) {
  if (cond) [[unlikely]] {
    return lhs;
  } else {
    return rhs;
  }
};

template<auto Probablity>
inline constexpr auto conditional_probability = [](const bool cond, const auto lhs, const auto rhs) {
  if (__builtin_expect_with_probability(cond, 1, Probablity)) {
    return lhs;
  } else {
    return rhs;
  }
};

inline constexpr auto branchless = [](const bool cond, const auto lhs, [[maybe_unused]] const auto rhs) {
  return cond * lhs; // generates cmov (x86-64)
};

namespace detail {
template<class T> using key_t = std::conditional_t<std::is_integral_v<T>, T, std::uint64_t>;
template<class T> using mask_t = std::conditional_t<sizeof(T) <= sizeof(std::uint32_t), std::uint32_t, std::uint64_t>;
} // namespace detail

template<auto kv, typename decltype(kv)::value_type::second_type unknown, auto policy = conditional>
[[nodiscard]] constexpr auto hash(auto&& key) noexcept -> decltype(unknown) {
  if (std::is_constant_evaluated()) {
    for (const auto& [k, v] : kv) {
      if constexpr (requires { k.size(); key.size(); k[0]; key[0]; }) {
        if (k.size() == key.size()) {
          auto matched = true;
          for (auto i = 0u; i < key.size(); ++i) {
            if (k[i] != key[i]) {
              matched = false;
              break;
            }
          }
          if (matched) {
            return v;
          }
        }
      } else {
        if (k == key) {
          return v;
        }
      }
    }
  } else {
    return [&] {
      if constexpr (kv.size() == 0u) {
        return unknown;
      } else if constexpr (kv.size() == 1u) {
        if (kv[0].first == key) { return kv[0].second; }
        return unknown;
      } else if constexpr (kv.size() == 2u) {
        if (kv[0].first == key) { return kv[0].second; }
        if (kv[1].first == key) { return kv[1].second; }
        return unknown;
      } else if constexpr (kv.size() <= 128u) {
        using key_type = detail::key_t<typename decltype(kv)::value_type::first_type>;
        using value_type = typename decltype(kv)::value_type::second_type;
        using mask_type = detail::mask_t<key_type>;
        static constexpr mask_type mask = utility::pext_mask<key_type>(kv);
        static constexpr const auto lut = [] {
          std::array<std::pair<key_type, value_type>, (mask_type(1u) << std::popcount(mask))> lut{};
          lut.fill(std::pair{key_type{}, unknown});
          for (const auto& [key, value] : kv) {
            const auto k = utility::as<key_type>(key);
            const auto pext = utility::pext<key_type>(k, mask);
            lut[pext] = std::pair{k, value};
          }
          return lut;
        }();
        auto&& lhs = [&] {
          if constexpr (requires { key.size(); }) {
            return utility::to<key_type>(key);
          } else {
            return std::forward<decltype(key)>(key);
          }
        }();
        auto&& [rhs, value] = lut[utility::pext(lhs, mask)];
        return policy(lhs == rhs, value, unknown);
      } else {
        constexpr auto not_supported = not sizeof(key);
        static_assert(not_supported, "[ERROR] hash is not supported!");
      }
    }();
  }
  return unknown;
}
}  // namespace mph::inline v2_0_0

#if not defined(DISABLE_STATIC_ASSERT_TESTS)
static_assert(([] {
  // mph::utility::pext
  {
    static_assert(0b00 == mph::utility::pext(0b00, 0b00));
    static_assert(0b00 == mph::utility::pext(0b01, 0b00));
    static_assert(0b01 == mph::utility::pext(0b01, 0b01));
    static_assert(0b01 == mph::utility::pext(0b01, 0b11));
    static_assert(0b00 == mph::utility::pext(0b01, 0b10));
    static_assert(0b01 == mph::utility::pext(0b11, 0b10));
    static_assert(0b01 == mph::utility::pext(0b11, 0b01));
    static_assert(0b11 == mph::utility::pext(0b11, 0b11));
  }

  // mph::utility::pext_mask
  {
    static_assert(0b10 == mph::utility::pext_mask<std::uint32_t>(std::array{std::pair{0b10, 0}, std::pair{0b00, 0}}));
    static_assert(0b01 == mph::utility::pext_mask<std::uint32_t>(std::array{std::pair{0b00, 0}, std::pair{0b01, 0}}));
    static_assert(0b01 == mph::utility::pext_mask<std::uint32_t>(std::array{std::pair{0b10, 0}, std::pair{0b01, 0}}));
    static_assert(0b01 == mph::utility::pext_mask<std::uint32_t>(std::array{std::pair{0b11, 0}, std::pair{0b00, 0}}));
    static_assert(0b01 == mph::utility::pext_mask<std::uint32_t>(std::array{std::pair{0b00, 0}, std::pair{0b11, 0}}));
  }

  // mph::utility::unique
  {
    static_assert(mph::utility::unique(std::array{1}));
    static_assert(mph::utility::unique(std::array{1, 2}));
    static_assert(mph::utility::unique(std::array{1, 2, 3}));
    static_assert(not mph::utility::unique(std::array{1, 1}));
    static_assert(not mph::utility::unique(std::array{1, 2, 1}));
    static_assert(not mph::utility::unique(std::array{1, 2, 3, 2}));
  }

  // mph::utility::as
  {
    static_assert(int(0) == mph::utility::as<int>(std::array{0}));
    static_assert(int(1) == mph::utility::as<int>(std::array{1}));
    static_assert((int(1) << 0) + (int(2) << CHAR_BIT) == mph::utility::as<int>(std::array{1, 2}));
    static_assert((int(1) << 0) + (int(2) << CHAR_BIT)  + (int(3) << CHAR_BIT*2) == mph::utility::as<int>(std::array{1, 2, 3}));
  }

  // mph::fixed_string
  {
    static_assert(0u == std::size(mph::fixed_string{}));
    static_assert(0u == std::size(mph::fixed_string{""}));
    static_assert(3u == std::size(mph::fixed_string{"abc"}));
    static_assert('a' == mph::fixed_string{"abc"}[0]);
    static_assert('a' == mph::fixed_string{"abc"}[0]);
    static_assert('b' == mph::fixed_string{"abc"}[1]);
    static_assert('c' == mph::fixed_string{"abc"}[2]);
    static_assert(mph::fixed_string{"abc"} == mph::fixed_string{"abc"});
    static_assert(mph::fixed_string{"foo"} != mph::fixed_string{"bar"});
  }

  // mph::policies
  {
    static_assert(1 == mph::unconditional(true, 1, 2));
    static_assert(1 == mph::unconditional(false, 1, 2));

    static_assert(1 == mph::conditional(true, 1, 2));
    static_assert(2 == mph::conditional(false, 1, 2));

    static_assert(1 == mph::likely(true, 1, 2));
    static_assert(2 == mph::likely(false, 1, 2));

    static_assert(1 == mph::unlikely(true, 1, 2));
    static_assert(2 == mph::unlikely(false, 1, 2));

    static_assert(1 == mph::conditional_probability<1>(true, 1, 2));
    static_assert(2 == mph::conditional_probability<1>(false, 1, 2));

    static_assert(1 == mph::branchless(true, 1, 2));
    static_assert(0 == mph::branchless(false, 1, 2));
  }

  // mph::hash
  {
    // integral
    {
      {
        constexpr std::array<std::pair<int, int>, 0> kv{ };

        static_assert(0 == mph::hash<kv, 0>(0));
        static_assert(0 == mph::hash<kv, 0>(1));
        static_assert(0 == mph::hash<kv, 0>(2));
        static_assert(1 == mph::hash<kv, 1>(0));
      }

      {
        constexpr std::array kv{
          std::pair{std::uint32_t(4), std::uint32_t(2)},
        };

        static_assert(0 == mph::hash<kv, 0>(std::uint32_t(0)));
        static_assert(0 == mph::hash<kv, 0>(std::uint32_t(1)));
        static_assert(2 == mph::hash<kv, 0>(std::uint32_t(4)));
      }

      {
        constexpr std::array kv{
          std::pair{std::uint32_t(4), std::uint32_t(2)},
          std::pair{std::uint32_t(42), std::uint32_t(87)},
          std::pair{std::uint32_t(100), std::uint32_t(100)},
        };

        static_assert(0 == mph::hash<kv, 0>(std::uint32_t(0)));
        static_assert(1 == mph::hash<kv, 1>(std::uint32_t(0)));
        static_assert(2 == mph::hash<kv, 0>(std::uint32_t(4)));
        static_assert(87 == mph::hash<kv, 0>(std::uint32_t(42)));
        static_assert(100 == mph::hash<kv, 0>(std::uint32_t(100)));
      }
    }

    // string-like
    {
      {
        enum class color { red = 1, green = 2, blue = 3 };

        constexpr std::array kv{
          std::pair{mph::fixed_string{"green"}, color::green},
          std::pair{mph::fixed_string{"red"}, color::red},
          std::pair{mph::fixed_string{"blue"}, color::blue},
        };

        static_assert(color(0) == mph::hash<kv, color(0)>(std::array<char, 0>{}));
        static_assert(color(-1) == mph::hash<kv, color(-1)>(std::array<char, 4>{'n', 'o', 'n', 'e'}));
        static_assert(color(0) == mph::hash<kv, color(0)>(std::array<char, 7>{'u', 'n', 'k', 'n', 'o', 'w', 'n'}));
        static_assert(color::red == mph::hash<kv, color(0)>(std::array<char, 3>{'r', 'e', 'd'}));
        static_assert(color::green == mph::hash<kv, color(0)>(std::array<char, 5>{'g', 'r', 'e', 'e', 'n'}));
        static_assert(color::blue == mph::hash<kv, color(0)>(std::array<char, 4>{'b', 'l', 'u', 'e'}));
      }
    }
  }
}(), true));
#endif
#endif  // MPH
