//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef MPH
#define MPH 3'0'0 // SemVer
#pragma GCC system_header

/**
 * [Minimal] Perfect hash library (https://github.com/boost-ext/mph)
 */
namespace mph::inline v2_5_0 {
using u8   = __UINT8_TYPE__;
using u16  = __UINT16_TYPE__;
using u32  = __UINT32_TYPE__;
using u64  = __UINT64_TYPE__;
using u128 = unsigned __int128;

namespace utility {
template<class T1, class T2>
struct compressed_pair {
  using first_type = T1;
  using second_type = T2;
  [[no_unique_address]] T1 first;
  [[no_unique_address]] T2 second;
};
template<class T1, class T2> compressed_pair(T1, T2) -> compressed_pair<T1, T2>;

template<class T, u32 Size>
struct array {
  using value_type = T;
  [[nodiscard]] constexpr const T* data() const noexcept { return data_; }
  [[nodiscard]] constexpr T* data() noexcept { return data_; }
  [[nodiscard]] constexpr auto begin() const noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto begin() noexcept { return &data_[0]; }
  [[nodiscard]] constexpr auto end() const noexcept { return &data_[0] + Size; }
  [[nodiscard]] constexpr auto end() noexcept { return &data_[0] + Size; }
  [[nodiscard]] constexpr auto size() const noexcept { return Size; }
  [[nodiscard]] constexpr const auto& operator[](u32 i) const noexcept { return data_[i]; }
  [[nodiscard]] constexpr auto& operator[](u32 i) noexcept { return data_[i]; }
  constexpr void fill(const T& value) noexcept { for (auto i = 0u; i < Size; ++i) { data_[i] = value; } }
  T data_[Size];
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;
} // namespace utility

namespace type_traits {
template<class T, u32 alignment>
struct aligned {
  using type = struct alignas(alignment) a  : T { };
  static_assert(alignment == alignof(type));
};
template<class T> struct aligned<T, 0u> { using type = T; };
template<class T, u32 alignment>
using aligned_t = typename aligned<T, alignment>::type;

namespace detail {
template <bool> struct conditional;
template <> struct conditional<false> { template <class, class T> using fn = T; };
template <> struct conditional<true>  { template <class T, class> using fn = T; };
template<class T> auto value_type(const T&) -> typename T::value_type;
} // namespace detail

template <bool B, class T, class F>
using conditional_t = typename detail::conditional<B>::template fn<T, F>;

template<const auto& kv>
using value_type_t = decltype(detail::value_type(kv));

template<auto v> struct constant {
  static constexpr auto value = v;
  constexpr operator auto() const noexcept { return value; }
};
template<auto v> inline constexpr constant<v> constant_v{};
} // namespace type_traits

namespace detail {
template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto pext(const T a, const auto mask) noexcept -> T {
  // https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
  if (constexpr T size = sizeof(T) * __CHAR_BIT__; __builtin_is_constant_evaluated()) {
    T result{};
    T m = mask;
    auto k = 0u;
    for (T i{}; i < size; ++i) {
      if (m & 1) result |= ((a >> i) & 1) << k++;
      m >>= 1;
    }
    return result;
  }
  #if defined(__BMI2__)
  else if constexpr (requires { u32{mask}; }) { return __builtin_ia32_pext_si(a, mask); }
  else if constexpr (requires { u64{mask}; }) { return __builtin_ia32_pext_di(a, mask); }
  #endif
  else if constexpr (requires { mask.value; }) {
    // https://stackoverflow.com/questions/14547087/extracting-bits-with-a-single-multiplication
    return [&] {
      static constexpr auto nbits = __builtin_popcountl(mask);
      static constexpr auto cbits = size - nbits -
        (sizeof(mask.value) <= sizeof(u32) ? __builtin_clz(mask) : __builtin_clzl(mask));
      static constexpr auto coefficient = [&] {
        auto set = false;
        auto dst = cbits;
        T result{};
        for (auto i = 0u; i < size; ++i) {
          const auto curr = ((T(1) << i) & mask) != T();
          if (curr and not set) result = result | (T(1) << (dst - i));
          dst += curr;
          set = curr;
        }
        return result;
      }();
      return ((a & mask) * coefficient >> cbits) & ((T(1) << nbits) - T(1));
    }();
  }
  return {};
}

template<class T, u32 N>
[[nodiscard]] constexpr auto mask(const auto& v) noexcept -> T {
  utility::array<T, decltype(v){}.size()> vs;
  T max{};
  u32 size{};
  for (auto i = 0u; i < vs.size(); ++i) {
    if (not v[i].first) break;
    if (vs[i] = v[i].first; vs[i] > max) max = vs[i];
    ++size;
  }
  if (size <= 1u) {
    return {};
  }
  constexpr auto H = (N * vs.size()) << 1u;
  constexpr auto N_ = N - 1u;
  const auto clz = sizeof(max) <= sizeof(u32) ? __builtin_clz(max) : __builtin_clzl(max);
  const auto nbits = sizeof(T) * __CHAR_BIT__ - clz - 1u;
  utility::array<T, H> hashed;
  T mask = ((T(1) << nbits) - 1u);
  for (int i = nbits; i >= 0; --i) {
    mask &= ~(T(1) << i);
    hashed = {};
    for (auto j = 0u; j < size; ++j) {
      const auto masked = (vs[j] & mask) + 1u;
      auto slot = masked % H;
      auto n = N_;
      auto found = false;
      while (hashed[slot]) {
        if (hashed[slot] == masked and not n--) {
          found = true;
          break;
        }
        slot = (slot + 1u) % H;
      }
      if (found) {
        mask |= (T(1) << i);
        break;
      }
      hashed[slot] = masked;
    }
  }
  return mask;
}

template<class T>
[[nodiscard]] [[gnu::always_inline]] constexpr auto to(const auto& data) noexcept -> T {
  if (__builtin_is_constant_evaluated()) {
    if constexpr (requires { data.data(); data.size(); }) {
      T t{};
      for (auto i = 0u; i < data.size(); ++i) {
        t = (t << __CHAR_BIT__) | data.data()[data.size() - i - 1u];
      }
      return t;
    } else if constexpr (requires(u32 n) { data[n]; }) {
      u32 size{};
      auto ptr = data;
      while (*ptr++) size++;
      T t{};
      for (auto i = 0u; i < size; ++i) {
        t = (t << __CHAR_BIT__) | data[size - i - 1u];
      }
      return t;
    } else {
      return data;
    }
  } else if constexpr (requires { T(data); data + decltype(data){}; }) {
    return data;
  } else if constexpr (requires { data.data(); data.size(); }) {
    if constexpr (requires { []<template<class, auto> class T_, class _, auto size>(T_<_, size>){}(data); }) {
      return [&]<template<class, auto> class T_, class _, auto size>(T_<_, size>) {
        if constexpr (not size) {
          return T{};
        } else if constexpr (size == sizeof(T)) {
          return *__builtin_bit_cast(const T*, data.data());
        } else if constexpr (size <= sizeof(T)) {
          T t{};
          __builtin_memcpy(&t, data.data(), size);
          return t;
        }
      }(data);
    } else {
      #if defined(MPH_PAGE_SIZE)
      // https://github.com/bminor/glibc/blob/master/sysdeps/generic/memcopy.h#L162
      if ((u64(data.data()) & (MPH_PAGE_SIZE - 1ul)) > (MPH_PAGE_SIZE - sizeof(T))) [[unlikely]] {
        return [&data] [[gnu::cold]] { // unlikely path
          T t{};
          __builtin_memcpy(&t, data.data(), data.size());
          return t;
        }();
      }
      #endif
      T t;
      __builtin_memcpy(&t, data.data(), sizeof(t));
      const auto index = T(data.size() * __CHAR_BIT__);
      #if defined(__BMI2__)
      if constexpr (sizeof(t) <= sizeof(u32)) {
        return __builtin_ia32_bzhi_si(t, index);
      } else if constexpr (sizeof(t) <= sizeof(u64)) {
        return __builtin_ia32_bzhi_di(t, index);
      } else
      #endif
        return t & ((T(1) << index) - T(1));
    }
  }
  return {};
}

[[nodiscard]] constexpr auto bucket_size(const auto& kv) {
  if (kv.size() == 0u) return 0u;
  if (kv.size() <= 1024u) return 1u;
  if (kv.size() <= 2048u) return 4u;
  if (kv.size() <= 4096u) return 8u;
  return 16u;
};

template<const auto& kv>
[[nodiscard]] constexpr decltype(auto) key_values() {
  if constexpr (requires { kv[0].size(); }) { // array{"a"sv, "b"sv, ...}
    constexpr auto max_len = [] {
      u32 len{};
      for (const auto& key : kv) { if (key.size() > len) { len = key.size(); } }
      return len;
    }();

    using key_type = decltype([] {
          if constexpr (max_len <= sizeof(u8)) { return u8{}; }
     else if constexpr (max_len <= sizeof(u16)) { return u16{}; }
     else if constexpr (max_len <= sizeof(u32)) { return u32{}; }
     else if constexpr (max_len <= sizeof(u64)) { return u64{}; }
     else if constexpr (max_len <= sizeof(u128)) { return u128{}; }
    }());

    using mapped_type = decltype([] {
           if constexpr (kv.size() < u8{}-1u) { return u8{}; }
      else if constexpr (kv.size() < u16{}-1u) { return u16{}; }
      else if constexpr (kv.size() < u32{}-1u) { return u32{}; }
      else if constexpr (kv.size() < u64{}-1u) { return u64{}; }
      else if constexpr (kv.size() < u128{}-1u) { return u128{}; }
    }());

    utility::array<utility::compressed_pair<key_type, mapped_type>, kv.size()> kv_;
    for (mapped_type i{}; i < kv.size(); ++i) {
      kv_[i] = utility::compressed_pair{to<key_type>(kv[i]), mapped_type(i + 1u)};
    }
    return kv_;
  } else if constexpr (requires (u32 n) { kv[n].first.size(); kv[n].second; }) { // array{pair{"a"sv, 1}, ...}
    constexpr auto max_len = [] {
      u32 len{};
      for (const auto& key : kv) { if (key.first.size() > len) { len = key.first.size(); } }
      return len;
    }();

    using key_type = decltype([] {
          if constexpr (max_len <= sizeof(u8)) { return u8{}; }
     else if constexpr (max_len <= sizeof(u16)) { return u16{}; }
     else if constexpr (max_len <= sizeof(u32)) { return u32{}; }
     else if constexpr (max_len <= sizeof(u64)) { return u64{}; }
     else if constexpr (max_len <= sizeof(u128)) { return u128{}; }
    }());

    using mapped_type = typename type_traits::value_type_t<kv>::second_type;

    utility::array<utility::compressed_pair<key_type, mapped_type>, kv.size()> kv_;
    for (auto i = 0; i < kv.size(); ++i) {
      kv_[i] = utility::compressed_pair{to<key_type>(kv[i].first), kv[i].second};
    }
    return kv_;
  } else if constexpr (not requires (u32 n) { kv[n].first; kv[n].second; }) { // array{1, 2, 3, ...}
    using key_type = type_traits::value_type_t<kv>;
    using mapped_type = decltype([] {
           if constexpr (kv.size() < u8{}-1u) { return u8{}; }
      else if constexpr (kv.size() < u16{}-1u) { return u16{}; }
      else if constexpr (kv.size() < u32{}-1u) { return u32{}; }
      else if constexpr (kv.size() < u64{}-1u) { return u64{}; }
      else if constexpr (kv.size() < u128{}-1u) { return u128{}; }
    }());

    utility::array<utility::compressed_pair<key_type, mapped_type>, kv.size()> kv_;
    for (auto i = 0u; i < kv.size(); ++i) {
      kv_[i] = utility::compressed_pair{kv[i], mapped_type(i + 1u)};
    }
    return kv_;
  } else { // array{pair{1, 2}, ...}
    return kv;
  }
}
} // namespace detail

enum : u8 {
  contains = 0b0001,
  lookup   = 0b0010,
  find     = 0b0100,
  iterate  = 0b1000,
};

template<u8 Probability = 50u>
  requires (Probability >= 0u and Probability <= 100u)
inline constexpr auto conditional =
  []<class T>(const bool cond, const T lhs, const T rhs) {
    if (__builtin_is_constant_evaluated()) {
      return cond ? lhs : rhs;
    } else
    #if __has_builtin(__builtin_unpredictable)
    if constexpr (Probability == 50u) {
     return __builtin_unpredictable(cond) ? lhs : rhs;
    }
    else
    #endif
    if constexpr (Probability == 50u) {
      return T(cond * lhs);
    } else {
      constexpr auto probability = [] { return float(Probability) / float(100u); }();
      return __builtin_expect_with_probability(cond, 1, probability) ? lhs : rhs;
    }
  };

template<
  const auto& kv,
  auto operations = lookup | contains | find | iterate,
  u32 bucket_size = detail::bucket_size(kv),
  u32 alignment = u32{}
> class static_hash_map {
  static constexpr auto kv_ = detail::key_values<kv>();

 public:
  using key_type = type_traits::value_type_t<kv_>::first_type;
  using mapped_type = type_traits::value_type_t<kv_>::second_type;

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto lookup([[maybe_unused]] const auto& key) noexcept -> bool requires (bool(operations & mph::lookup)) {
    return {};
  }

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto contains([[maybe_unused]] const auto& key) noexcept -> bool requires (bool(operations & mph::contains)) {
    return {};
  }

  template<auto...>
  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto find([[maybe_unused]] const auto& key) noexcept -> mapped_type requires (bool(operations & mph::find)) {
    return {};
  }

  static constexpr auto begin() noexcept requires (bool(operations & iterate)) { return kv_.begin(); }
  static constexpr auto end() noexcept requires (bool(operations & iterate)) { return kv_.end(); }
  static constexpr auto cbegin() noexcept requires (bool(operations & iterate)) { return kv_.begin(); }
  static constexpr auto cend() noexcept requires (bool(operations & iterate)) { return kv_.end(); }
};

template<const auto& keys, auto operations, u32 bucket_size, u32 alignment>
  requires (keys.size() == 1u)
class static_hash_map<keys, operations, bucket_size, alignment> {
  static constexpr auto kv_ = detail::key_values<keys>();

 public:
  using key_type = type_traits::value_type_t<kv_>::first_type;
  using mapped_type = type_traits::value_type_t<kv_>::second_type;

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto lookup([[maybe_unused]] const auto& key) noexcept -> mapped_type requires (bool(operations & mph::lookup)) {
    return kv_[0].second;
  }

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto contains(const auto& key) noexcept -> bool requires (bool(operations & mph::contains)) {
    return detail::to<key_type>(key) == kv_[0].first;
  }

  template<auto conditional = conditional<>>
  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto find(const auto& key) noexcept -> mapped_type requires (bool(operations & mph::find)) {
    return conditional(
      detail::to<key_type>(key) == kv_[0].first,
      mapped_type(kv_[0].second),
      mapped_type{}
    );
  }

  static constexpr auto begin() noexcept requires (bool(operations & mph::iterate)) { return kv_.begin(); }
  static constexpr auto end() noexcept requires (bool(operations & mph::iterate)) { return kv_.end(); }
  static constexpr auto cbegin() noexcept requires (bool(operations & mph::iterate)) { return kv_.begin(); }
  static constexpr auto cend() noexcept requires (bool(operations & mph::iterate)) { return kv_.end(); }
};

template<const auto& keys, auto operations, u32 bucket_size, u32 alignment>
  requires (keys.size() > 1u and bucket_size == 1u)
class static_hash_map<keys, operations, bucket_size, alignment> {
  static constexpr auto kv_ = detail::key_values<keys>();

 public:
  using key_type = type_traits::value_type_t<kv_>::first_type;
  using mapped_type = type_traits::value_type_t<kv_>::second_type;

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto lookup(const auto& key) noexcept -> mapped_type requires (bool(operations & mph::lookup)) {
    auto& lhs = lookup_[detail::pext(detail::to<key_type>(key), mask_)];
    if constexpr (requires { lhs.second; }) {
      return lhs.second;
    } else {
      return lhs;
    }
  }

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto contains(const auto& key) noexcept -> bool requires (bool(operations & mph::contains)) {
    auto&& lhs = detail::to<key_type>(key);
    auto&& rhs = lookup_[detail::pext(lhs, mask_)];
    return lhs == rhs.first;
  }

  template<auto conditional = conditional<>>
  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto find(const auto& key) noexcept -> mapped_type requires (bool(operations & mph::find)) {
    auto&& lhs = detail::to<key_type>(key);
    auto&& rhs = lookup_[detail::pext(lhs, mask_)];
    return conditional(lhs == rhs.first, mapped_type(rhs.second), mapped_type{});
  }

  static constexpr auto begin() noexcept requires (bool(operations & mph::iterate)) { return kv_.begin(); }
  static constexpr auto end() noexcept requires (bool(operations & mph::iterate)) { return kv_.end(); }
  static constexpr auto cbegin() noexcept requires (bool(operations & mph::iterate)) { return kv_.begin(); }
  static constexpr auto cend() noexcept requires (bool(operations & mph::iterate)) { return kv_.end(); }

 private:
  using mask_type = type_traits::conditional_t<
    sizeof(key_type) <= sizeof(u32),
    u32,
    u64
  >;

  static constexpr const auto mask_ =
    type_traits::constant_v<mask_type(detail::mask<key_type, bucket_size>(kv_))>;

  static constexpr const auto lookup_ = [] {
    using key_mapped_type = type_traits::conditional_t<
      bool(operations & mph::contains) or bool(operations & mph::find),
      utility::compressed_pair<key_type, mapped_type>,
      key_type
    >;

    type_traits::aligned_t<
      utility::array<key_mapped_type, mask_type(1) << __builtin_popcountl(mask_)>,
      alignment
    > lookup{};

    for (const auto& [key, value] : kv_) {
      auto& lhs = lookup[detail::pext(key, mask_)];
      if constexpr (requires { lhs.first; lhs.second; }) {
        lhs = utility::compressed_pair{key, value};
      } else {
        lhs = value;
      }
    }

    return lookup;
  }();
};

template<const auto& kv, auto operations, u32 bucket_size, u32 alignment>
  requires (kv.size() > 1u and bucket_size > 1u)
class static_hash_map<kv, operations, bucket_size, alignment> {
  static constexpr auto kv_ = detail::key_values<kv>();

 public:
  using key_type = type_traits::value_type_t<kv_>::first_type;
  using mapped_type = type_traits::value_type_t<kv_>::second_type;

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto lookup(const auto& key) noexcept -> mapped_type requires (bool(operations & mph::lookup)) {
    auto&& lhs = detail::to<key_type>(key);
    auto&& lut = masks_offsets_.first[detail::pext(lhs, mask_)];
    return *static_cast<const key_mapped_type*>(&lookups_[lut.first + detail::pext(lhs, lut.second)]);
  }

  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto contains(const auto& key) noexcept -> bool requires (bool(operations & mph::contains)) {
    auto&& lhs = detail::to<key_type>(key);
    auto&& lut = masks_offsets_.first[detail::pext(lhs, mask_)];
    auto&& rhs = *static_cast<const key_mapped_type*>(&lookups_[lut.first + detail::pext(lhs, lut.second)]);
    return lhs == rhs.first;
  }

  template<auto conditional = conditional<>>
  [[nodiscard]] [[gnu::always_inline]]
  static constexpr auto find(const auto& key) noexcept -> mapped_type requires (bool(operations & mph::find)) {
    auto&& lhs = detail::to<key_type>(key);
    auto&& lut = masks_offsets_.first[detail::pext(lhs, mask_)];
    auto&& rhs = *static_cast<const key_mapped_type*>(&lookups_[lut.first + detail::pext(lhs, lut.second)]);
    return conditional(lhs == rhs.first, mapped_type(rhs.second), mapped_type{});
  }

  static constexpr auto begin() noexcept requires (bool(operations & mph::iterate)) { return kv_.begin(); }
  static constexpr auto end() noexcept requires (bool(operations & mph::iterate)) { return kv_.end(); }
  static constexpr auto cbegin() noexcept requires (bool(operations & mph::iterate)) { return kv_.begin(); }
  static constexpr auto cend() noexcept requires (bool(operations & mph::iterate)) { return kv_.end(); }

 private:
  using mask_type = type_traits::conditional_t<
    sizeof(key_type) <= sizeof(u32),
    u32,
    u64
  >;

  using key_mapped_type = type_traits::conditional_t<
    bool(operations & mph::contains) or bool(operations & mph::find),
    utility::compressed_pair<key_type, mapped_type>,
    mapped_type
  >;

  static constexpr const auto mask_ =
    type_traits::constant_v<mask_type(detail::mask<key_type, bucket_size>(kv))>;

  static constexpr const auto lookup_ = [] {
    utility::array<
      utility::array<utility::compressed_pair<key_type, mapped_type>, bucket_size>,
      mask_type(1) << __builtin_popcountl(mask_)
    > lookup{};

    for (const auto& [key, value] : kv) {
      auto& slot = lookup[detail::pext(key, mask_)];
      auto n = 0u;
      while (slot[n].first) n++;
      slot[n] = utility::compressed_pair{key, value};
    }

    return lookup;
  }();

  static constexpr const auto masks_offsets_ = [] {
    type_traits::aligned_t<
      utility::array<utility::compressed_pair<u32, mask_type>, lookup_.size()>,
      alignment
    > masks_offsets{};
    u32 offset{};

    for (auto i = 0u; i < lookup_.size(); ++i) {
      if (const auto& slot = lookup_[i]; slot[0].first) {
        const auto mask = detail::mask<key_type, 1u>(slot);
        masks_offsets[i] = utility::compressed_pair{offset, mask};
        offset += (mask_type(1) << __builtin_popcountl(mask));
      }
    }

    return utility::compressed_pair{masks_offsets, offset};
  }();

  static constexpr const auto lookups_ = [] {
    type_traits::aligned_t<
      utility::array<key_mapped_type, masks_offsets_.second>,
      alignment
    > lookups{};

    for (auto i = 0u; i < lookup_.size(); ++i) {
      if (auto& lut = masks_offsets_.first[i]; lookup_[i][0].first) {
        for (const auto& [key, value] : lookup_[i]) {
          if (not key) break;
          auto& lhs = lookups[lut.first + detail::pext(key, lut.second)];
          if constexpr (requires { lhs.first; lhs.second; }) {
            lhs = utility::compressed_pair{key, value};
          } else {
            lhs = value;
          }
        }
      }
    }

    return lookups;
  }();
};
} // namespace mph

#if not defined(DISABLE_STATIC_ASSERT_TESTS)
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // mph::utility::compressed_pair
  {
    static_assert(1 == mph::utility::compressed_pair{1, 2}.first);
    static_assert(2 == mph::utility::compressed_pair{1, 2}.second);
    static_assert(sizeof(int) + sizeof(int) == sizeof(mph::utility::compressed_pair{int{}, int{}}));
    struct empty { };
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{empty{}, 42}));
    static_assert(sizeof(int) == sizeof(mph::utility::compressed_pair{42, empty{}}));
    static_assert(sizeof(empty) + sizeof(empty) == sizeof(mph::utility::compressed_pair{empty{}, empty{}}));
  }

  // mph::utility::array
  {
    {
      mph::utility::array<mph::u32, 1> a{};
      expect(1 == a.size());
    }

    {
      mph::utility::array a{1, 2};
      expect(2u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
    }

    {
      mph::utility::array a{1};
      a[0] = 2;
      expect(2 == a[0]);
    }

    {
      mph::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(a.begin() != a.end());
      expect(a.size() == mph::u32(a.end() - a.begin()));
      expect(a.end() == a.begin() + a.size());
    }
  }

  // mph::utility::constant/_v
  {
    static_assert(0 == mph::type_traits::constant<0>::value);
    static_assert(0 == mph::type_traits::constant_v<0>);
    static_assert(42 == mph::type_traits::constant<42>{});
    static_assert(42 == mph::type_traits::constant_v<42>);
    static_assert(42u == mph::type_traits::constant<42u>::value);
    static_assert('X' == mph::type_traits::constant<'X'>::value);
    static_assert('X' == mph::type_traits::constant_v<'X'>);
  }

  // mph::type_traits::aligned_t
  {
    using mph::utility::array;

    static_assert(16u == alignof(mph::type_traits::aligned_t<array<int, 42>, 16u>));
    static_assert(32u == alignof(mph::type_traits::aligned_t<array<int, 42>, 32u>));
    static_assert(64u == alignof(mph::type_traits::aligned_t<array<int, 42>, 64u>));
    static_assert(alignof(int) == alignof(mph::type_traits::aligned_t<array<int, 42>, 0u>));
  }

  // mph::type_traits::conditional_t
  {
    using mph::u32;
    using mph::u64;

    static_assert(sizeof(u32) == sizeof(mph::type_traits::conditional_t<true, u32, u64>));
    static_assert(sizeof(u64) == sizeof(mph::type_traits::conditional_t<false, u32, u64>));
  }

  // mph::detail::pext
  {
    using mph::u32;

    static_assert(0    == mph::detail::pext(0b00, 0b00));
    static_assert(0    == mph::detail::pext(0b01, 0b00));
    static_assert(0b1  == mph::detail::pext(0b01, 0b01));
    static_assert(0b01 == mph::detail::pext(0b01, 0b11));
    static_assert(0b0  == mph::detail::pext(0b01, 0b10));
    static_assert(0b1  == mph::detail::pext(0b11, 0b10));
    static_assert(0b1  == mph::detail::pext(0b11, 0b01));
    static_assert(0b11 == mph::detail::pext(0b11, 0b11));
  }

  // mph::detail::mask
  {
    using mph::u32;
    using mph::utility::array;
    using mph::utility::compressed_pair;

    static_assert(0b01 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b10, 0}, compressed_pair{0b11, 0}}));
    static_assert(0b10 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b01, 0}, compressed_pair{0b11, 0}}));
    static_assert(0b10 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b11, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b01 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b11, 0}, compressed_pair{0b10, 0}}));
    static_assert(0b01 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b01, 0}, compressed_pair{0b10, 0}}));
    static_assert(0b01 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b10, 0}, compressed_pair{0b01, 0}}));
    static_assert(0b11 == mph::detail::mask<u32, 1u>(array{compressed_pair{0b11, 0}, compressed_pair{0b11, 0}}));
  }

  // mph::datail::to
  {
    using mph::u32;
    using mph::utility::array;

    static_assert(0 == mph::detail::to<u32>(0));
    static_assert(42 == mph::detail::to<u32>(42));
    static_assert(42u == mph::detail::to<u32>(42u));
    static_assert(0 == mph::detail::to<u32>(""));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) == mph::detail::to<u32>("AB"));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) + (u32('C') << __CHAR_BIT__*2) == mph::detail::to<u32>("ABC"));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) == mph::detail::to<u32>(array{'A','B'}));
    static_assert((u32('A') << 0) + (u32('B') << __CHAR_BIT__) + (u32('C') << __CHAR_BIT__*2) == mph::detail::to<u32>(array{'A','B','C'}));
  }

  // mph::datail::key_values
  {
    using mph::u8;
    using mph::u32;
    using mph::utility::compressed_pair;
    using mph::utility::array;
    using mph::type_traits::constant;

    {
      constexpr const auto& kv = constant<array{compressed_pair{u32(4), u32(2)}}>::value;
      static_assert(&kv == &mph::detail::key_values<kv>());
    }

    {
      constexpr const auto& kv = constant<array{u32(4)}>::value;
      constexpr const auto v = mph::detail::key_values<kv>();
      static_assert(1u == v.size());
      static_assert(u32(4) == v[0].first);
      static_assert(u8(1) == v[0].second);
    }

    {
      constexpr const auto& kv = constant<array{u32(4), u32(2)}>::value;
      constexpr const auto v = mph::detail::key_values<kv>();
      static_assert(2u == v.size());
      static_assert(u32(4) == v[0].first);
      static_assert(u32(2) == v[1].first);
      static_assert(u8(1) == v[0].second);
      static_assert(u8(2) == v[1].second);
    }
  }

  // mph::static_hash_map
  {
    using mph::u32;
    using mph::utility::compressed_pair;
    using mph::utility::array;
    using mph::type_traits::constant;

    // integral
    {
      {
        constexpr const auto& kv = constant<array{
          compressed_pair{u32(4), u32(2)}
        }>::value;

        static_assert(not mph::static_hash_map<kv>::contains(u32(0)));
        static_assert(not mph::static_hash_map<kv>::contains(u32(1)));
        static_assert(mph::static_hash_map<kv>::contains(u32(4)));

        static_assert(2 == mph::static_hash_map<kv>::lookup(u32(4)));

        static_assert(0 == mph::static_hash_map<kv>::find(u32(0)));
        static_assert(0 == mph::static_hash_map<kv>::find(u32(1)));
        static_assert(2 == mph::static_hash_map<kv>::find(u32(4)));
      }

      {
        constexpr const auto& kv = constant<array{
          compressed_pair{u32(4), u32(2)},
          compressed_pair{u32(42), u32(87)},
          compressed_pair{u32(100), u32(100)},
        }>::value;

        static_assert(not mph::static_hash_map<kv>::contains(u32(0)));
        static_assert(not mph::static_hash_map<kv>::contains(u32(1)));
        static_assert(mph::static_hash_map<kv>::contains(u32(4)));
        static_assert(mph::static_hash_map<kv>::contains(u32(42)));
        static_assert(mph::static_hash_map<kv>::contains(u32(100)));

        static_assert(2 == mph::static_hash_map<kv>::lookup(u32(4)));
        static_assert(87 == mph::static_hash_map<kv>::lookup(u32(42)));
        static_assert(100 == mph::static_hash_map<kv>::lookup(u32(100)));

        static_assert(0 == mph::static_hash_map<kv>::find(u32(0)));
        static_assert(2 == mph::static_hash_map<kv>::find(u32(4)));
        static_assert(87 == mph::static_hash_map<kv>::find(u32(42)));
        static_assert(100 == mph::static_hash_map<kv>::find(u32(100)));
      }

      {
        constexpr const auto& kv = constant<array{
          compressed_pair{u32(4), u32(2)},
          compressed_pair{u32(42), u32(87)},
          compressed_pair{u32(100), u32(100)},
        }>::value;

        static_assert(not mph::static_hash_map<kv, mph::contains>::contains(u32(0)));
        static_assert(not mph::static_hash_map<kv, mph::contains>::contains(u32(1)));
        static_assert(mph::static_hash_map<kv, mph::contains>::contains(u32(4)));
        static_assert(mph::static_hash_map<kv, mph::contains>::contains(u32(42)));
        static_assert(mph::static_hash_map<kv, mph::contains>::contains(u32(100)));

        static_assert(2 == mph::static_hash_map<kv, mph::lookup>::lookup(u32(4)));
        static_assert(87 == mph::static_hash_map<kv, mph::lookup>::lookup(u32(42)));
        static_assert(100 == mph::static_hash_map<kv, mph::lookup>::lookup(u32(100)));

        static_assert(0 == mph::static_hash_map<kv, mph::find>::find(u32(0)));
        static_assert(2 == mph::static_hash_map<kv, mph::find>::find(u32(4)));
        static_assert(87 == mph::static_hash_map<kv, mph::find>::find(u32(42)));
        static_assert(100 == mph::static_hash_map<kv, mph::find>::find(u32(100)));
      }
    }

    // string-like
    {
      using mph::detail::to;

      {
        constexpr const auto& kv = constant<array{
          compressed_pair{to<u32>("BTC"), 1},
          compressed_pair{to<u32>("ETH"), 2},
          compressed_pair{to<u32>("XRP"), 3},
        }>::value;

        static_assert(not mph::static_hash_map<kv>::contains(""));
        static_assert(mph::static_hash_map<kv>::contains("BTC"));
        static_assert(mph::static_hash_map<kv>::contains("ETH"));
        static_assert(mph::static_hash_map<kv>::contains("XRP"));

        static_assert(1 == mph::static_hash_map<kv>::lookup("BTC"));
        static_assert(2 == mph::static_hash_map<kv>::lookup("ETH"));
        static_assert(3 == mph::static_hash_map<kv>::lookup("XRP"));

        static_assert(0 == mph::static_hash_map<kv>::find(""));
        static_assert(1 == mph::static_hash_map<kv>::find("BTC"));
        static_assert(2 == mph::static_hash_map<kv>::find("ETH"));
        static_assert(3 == mph::static_hash_map<kv>::find("XRP"));
      }
    }
  }
}(), true));
#endif
#endif // MPH
