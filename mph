//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#if __cplusplus < 202002L
#error "MPH requires C++20!"
#else
#ifndef MPH
#define MPH 1'0'0

#include <algorithm>
#include <array>
#include <bit>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <new>
#include <numeric>
#include <ranges>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <vector>

#if __has_include(<x86intrin.h>)
#include <x86intrin.h>
#endif

namespace mph::inline v_1_0_0 {
namespace utility {
#if defined(__cpp_lib_hardware_interference_size)
using std::hardware_constructive_interference_size;
#else
constexpr std::size_t hardware_constructive_interference_size = 64;
#endif
/**
 * https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
 *
 * DO WHILE m < 64
 * 	IF mask[m] == 1
 * 		dst[k] := tmp[m]
 * 		k := k + 1
 * 	FI
 * 	m := m + 1
 * OD
 */
template <class T>
[[nodiscard]] constexpr auto pext(const T a, T mask) {
  T result{};
  auto k = 0u;
  auto m = 0u;
  while (m < sizeof(T) * 8) {
    if ((mask & 1) == 1) {
      result |= ((a >> m) & 1) << k++;
    }
    mask >>= 1;
    ++m;
  }
  return result;
}

static_assert(0b00 == pext(0b00, 0b00));
static_assert(0b00 == pext(0b01, 0b00));
static_assert(0b01 == pext(0b01, 0b01));
static_assert(0b01 == pext(0b01, 0b11));
static_assert(0b00 == pext(0b01, 0b10));
static_assert(0b01 == pext(0b11, 0b10));
static_assert(0b01 == pext(0b11, 0b01));
static_assert(0b11 == pext(0b11, 0b11));

template <class T>
[[nodiscard]] constexpr auto as(const auto value) -> T {
  T result{};
  for (auto i = 0u; i < std::min(value.size(), sizeof(T)); ++i) {
    result = (result << 8) | value[std::min(value.size(), sizeof(T)) - 1 - i];  // little-endian
  }
  return result;
}

// clang-format off
static_assert(std::is_same_v<std::uint16_t, decltype(as<std::uint16_t>(std::array<std::uint8_t, 2>{0, 1}))>);
static_assert(std::uint32_t(0b00000001'00000000) == as<std::uint16_t>(std::array<std::uint8_t, 2>{0, 1}));
static_assert(std::is_same_v<std::uint16_t, decltype(as<std::uint16_t>( std::array<std::uint8_t, 2>{1, 0}))>);
static_assert(std::uint32_t(0b00000000'00000001) == as<std::uint16_t>(std::array<std::uint8_t, 2>{1, 0}));
static_assert(std::is_same_v<std::uint8_t, decltype(as<std::uint8_t>(std::string_view{"a"}))>);
static_assert(std::uint8_t('a') == as<std::uint8_t>(std::string_view{"a"}));
static_assert(std::is_same_v<std::uint32_t, decltype(as<std::uint32_t>(std::array<std::uint8_t, 4>{ 'a', 'b', 0, 0}))>);
static_assert(((std::uint32_t('b') << 8) | std::uint32_t('a') << 0) == as<std::uint32_t>(std::array<std::uint8_t, 4>{'a', 'b', 0, 0}));
static_assert(std::is_same_v<std::uint32_t, decltype(as<std::uint32_t>(std::array<std::uint8_t, 4>{0, 0, 'a', 'b'}))>);
static_assert(((std::uint32_t('b') << 24) | std::uint32_t('a') << 16) == as<std::uint32_t>(std::array<std::uint8_t, 4>{0, 0, 'a', 'b'}));
// clang-format on

template <std::size_t N>
  requires(N > 0)
struct bitset final {
  constexpr explicit(true) bitset(const auto value) {
    for (std::size_t i{}; i < N; ++i) {
      bits[i] = value & (1ull << i);
    }
  }
  constexpr auto set(const auto i, const auto value) { bits[i] = value; }
  [[nodiscard]] constexpr auto size() const { return bits.size(); }
  [[nodiscard]] constexpr auto operator[](const auto i) const { return bits[i]; }
  template <class T>
  [[nodiscard]] constexpr auto to() const -> T
    requires(sizeof(T) * 8 >= N)
  {
    T result{};
    for (auto i = 0u; i < N; ++i) {
      result |= static_cast<T>(bits[i]) << i;
    }
    return result;
  }
  std::array<bool, N> bits{};
};

static_assert(1 == bitset<1>{1}[0]);
static_assert(0 == bitset<1>{0}[0]);
static_assert(1 == bitset<2>{0b01}[0]);
static_assert(0 == bitset<2>{0b01}[1]);
static_assert(0b01 == bitset<2>{0b01}.to<int>());
static_assert(0b10 == bitset<2>{0b10}.to<int>());

template <class T>
[[nodiscard]] constexpr auto mask(const auto &symbols) {
  constexpr auto is_unique = [](const auto &symbols, const auto mask) {
    std::vector<T> v{};
    for (const auto &symbol : symbols) {
      const auto value = pext(as<T>(symbol), mask.template to<T>());
      if (std::find(std::cbegin(v), std::cend(v), value) != std::cend(v)) {
        return false;
      }
      v.push_back(value);
    }
    return true;
  };

  bitset<sizeof(T) * 8> mask(std::numeric_limits<T>::max());
  for (auto i = 0u; i < mask.size(); ++i) {
    mask.set(i, 0);
    if (not is_unique(symbols, mask)) {
      mask.set(i, 1);
    }
  }
  if (not is_unique(symbols, mask)) {
    throw;  // not a constant
  }
  return mask.template to<T>();
}

// clang-format off
static_assert(0b00000000'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 0}, std::array<std::uint8_t, 2>{0, 0}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{0, 0}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 0}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{0, 1}, std::array<std::uint8_t, 2>{1, 0}}));
static_assert(0b00000001'00000000 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 1}, std::array<std::uint8_t, 2>{1, 0}}));
static_assert(0b00000000'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 1}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000000'00000001'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{1, 1, 1}, std::array<std::uint8_t, 3>{0, 0, 0}, std::array<std::uint8_t, 3>{1, 0, 1}}));
static_assert(0b00000000'00000001'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{0, 0, 1}, std::array<std::uint8_t, 3>{1, 0, 1}, std::array<std::uint8_t, 3>{1, 1, 0}}));
static_assert(0b00000000'00000001'00000001 == mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{0, 0, 0}, std::array<std::uint8_t, 3>{1, 1, 1}, std::array<std::uint8_t, 3>{0, 1, 0}}));
// clang-format on
}  // namespace utility

/*
 * @return 0 if string doesn't match, 1..N for matches
 *  - requires symbols to have the same size <= 8 bytes
 *  - requires platform with bmi2 support (https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set)
 */
template <auto max_bits_size = 5>
class pext_direct {
  // template <const auto mask, const auto symbols>
  //[[nodiscard]] static constexpr auto make_lut() {
  // alignas(utility::hardware_constructive_interference_size) std::array<std::array<char, 8>, 32> lut{};

  // for (const auto &symbol : symbols()) {
  // auto &p = lut[utility::pext(utility::as<std::uint64_t>(symbol), mask)];
  //// mempcpy
  // for (auto k = 0u; k < std::size(symbol); ++k) {
  // p[k] = symbol[k];
  //}
  //}
  // return lut;
  //}

  template <const auto mask>
  [[nodiscard]] static constexpr auto make_index(const auto &symbols) {
    constexpr auto size = [] {  // std::pow is not constexpr
      std::size_t result{1};
      for (auto i = 0u; i < std::popcount(mask); ++i) {
        result *= 2;
      }
      return result;
    }();

    alignas(utility::hardware_constructive_interference_size) std::array<std::uint64_t, size> index{};
    auto i = 0;
    for (const auto &symbol : symbols()) {
      index[utility::pext(utility::as<std::uint64_t>(symbol), mask)] = ++i;
    }
    return index;
  }

 public:
  template <class TSymbols, const auto mask = utility::mask<std::uint64_t>(TSymbols{}())>
  [[nodiscard]] [[gnu::target("bmi2")]] auto operator()(const TSymbols s, const auto ptr, [[maybe_unused]] const auto size,
                                                        [[maybe_unused]] auto &&...args) const noexcept(true) -> std::size_t
    requires(std::uint32_t(std::popcount(mask)) <= max_bits_size and ([](const auto &symbols) {
               return not symbols.empty() and
                      std::all_of(std::cbegin(symbols), std::cend(symbols),
                                  [&symbols](const auto &symbol) { return symbol.size() == symbols[0].size(); }) and
                      std::all_of(std::cbegin(symbols), std::cend(symbols),
                                  [](const auto &symbol) { return symbol.size() <= sizeof(std::uint64_t); });
             }(s())))
  {
    // using v8si = std::int8_t __attribute__((vector_size(sizeof(std::uint64_t))));
    // using m128 = union {
    // std::uint64_t xmm;
    // v8si v8;
    //};
    static constexpr const auto index = make_index<mask>(s);
    // static constexpr const auto lut = make_lut<mask, TSymbols>();
    const auto lhs = *std::bit_cast<const std::uint64_t *>(ptr);
    const auto ext = _pext_u64(lhs, mask);
    return index[ext];
    // const auto rhs = std::bit_cast<const v8si*>(lut[ext].data());
    ////const auto idx = std::bit_cast<const v8si*>(std::addressof(index[ext]));
    // static constexpr auto max = (1ull << symbols()[0].size()*8) - 1ull;
    // const auto cmp = *std::bit_cast<const v8si*>(ptr) == *rhs;
    // const auto x = (cmp == max);
    // return std::bit_cast<const m128*>(std::addressof(x))->xmm==max * idx;
  }
};

template <auto max_bits_size = 5>
class pext_split_first_char {
  static constexpr auto calc_offset = [](const auto &s) {
    return (
        *std::min_element(std::cbegin(s), std::cend(s), [](const auto &lhs, const auto &rhs) { return lhs[0] < rhs[0]; }))[0];
  };

  template <std::ranges::range auto masks, const auto offset>
  [[nodiscard]] static constexpr auto make_luts(const auto &symbols) {
    std::vector<std::string_view> v[32]{};  // TODO max
    for (const auto &symbol : symbols()) {
      v[symbol[0] - offset].push_back(symbol);
    }
    alignas(utility::hardware_constructive_interference_size) std::array<std::array<std::array<char, 8>, 32>, 32> lut{};
    for (auto i = 0u; i < 32; ++i) {  // TODO max
      for (auto j = 0u; j < std::size(v[i]); ++j) {
        auto &p = lut[i][utility::pext(utility::as<std::uint64_t>(v[i][j]), masks[i])];
        for (auto k = 0u; k < 8; ++k) {  // TODO max
          p[k] = v[i][j][k];
        }
      }
    }
    return lut;
  }

  template <class T, const auto offset>
  [[nodiscard]] static constexpr auto make_masks(const auto &symbols) {
    std::vector<std::string_view> v[32]{};  // TODO max
    for (const auto &symbol : symbols()) {
      v[symbol[0] - offset].push_back(symbol);
    }
    alignas(utility::hardware_constructive_interference_size) std::array<T, 32> masks{};  // TODO max, pad to 64
    for (auto i = 0u; i < 32; ++i) {                                                      // TODO max
      masks[i] = utility::mask<T>(v[i]);
    }
    return masks;
  }

  template <const auto masks, const auto offset>
  [[nodiscard]] static constexpr auto make_indexes(const auto &symbols) {
    std::vector<std::size_t> idx[32]{};     // TODO max
    std::vector<std::string_view> v[32]{};  // TODO max
    auto i = 0;
    for (const auto &symbol : symbols()) {
      idx[symbol[0] - offset].push_back(++i);
      v[symbol[0] - offset].push_back(symbol);
    }
    alignas(utility::hardware_constructive_interference_size) std::array<std::array<std::uint64_t, 32>, 32>
        index{};  // TODO max
    for (auto i = 0u; i < 32; ++i) {
      for (auto j = 0u; j < v[i].size(); ++j) {
        index[i][utility::pext(utility::as<std::uint64_t>(v[i][j]), masks[i])] = idx[i][j];
      }
    }
    return index;
  }

 public:
  template <class TSymbols, const auto offset = calc_offset(TSymbols{}()),
            const auto masks = make_masks<std::uint64_t, offset>(TSymbols{})>
  [[nodiscard]] [[gnu::target("bmi2")]] auto operator()(const TSymbols s, const auto ptr, [[maybe_unused]] const auto size,
                                                        [[maybe_unused]] auto &&...args) const noexcept(true) -> std::size_t
    requires(std::all_of(std::cbegin(masks), std::cend(masks),
                         [](const auto mask) { return std::uint32_t(std::popcount(mask)) <= max_bits_size; }) and
             ([](const auto &symbols) {
               return not symbols.empty() and
                      std::all_of(std::cbegin(symbols), std::cend(symbols),
                                  [&symbols](const auto &symbol) { return symbol.size() == symbols[0].size(); }) and
                      std::all_of(std::cbegin(symbols), std::cend(symbols),
                                  [](const auto &symbol) { return symbol.size() <= sizeof(std::uint64_t); });
             }(s())))
  {
    // using v8si = std::int8_t __attribute__((vector_size(sizeof(std::uint64_t))));
    // using m128 = union {
    // std::uint64_t xmm;
    // v8si v8;
    //};
    // static constexpr const auto lut = make_luts<masks, symbols, offset>();
    static constexpr const auto index = make_indexes<masks, offset>(s);
    const auto id = ptr[0] - offset;
    const auto lhs = *std::bit_cast<const std::uint64_t *>(ptr);
    const auto ext = _pext_u64(lhs, masks[id]);
    // const auto rhs = std::bit_cast<const v8si *>(lut[id][ext].data());
    // const auto idx = std::bit_cast<const v8si *>(std::addressof(index[id][ext]));
    return index[id][ext];
  }
};

/**
 * Minimal perfect hash function (https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function)
 *
 * @tparam TSymbols compile time array of symbols
 * @tparam TPolicies compile time tuple of policies to be executed in given order
 */
template <class TSymbols, class TPolicies = std::tuple<pext_direct<5>, pext_split_first_char<5>>>
  requires(std::size(TSymbols{}()) > 0 and std::tuple_size_v<TPolicies> > 0)
class hash final {
 public:
  constexpr explicit(true) hash(TSymbols &&symbols, TPolicies &&policies = {})
      : symbols{std::move(symbols)}, policies{std::move(policies)} {}

  /**
   * @param data continuous input data
   * @param args... additonal parameters propagated to policies
   * @return result from executed policy
   */
  [[nodiscard]] constexpr auto operator()(const auto data, auto &&...args) const noexcept(true) -> std::size_t {
    if constexpr (std::is_pointer_v<decltype(data)>) {
      assert(data);
    }

    if constexpr (requires { data.size(); }) {
      assert(data.size() > 0);
    }

    return this->template operator()<0>(
        [](const auto data) {
          if constexpr (requires { data.data(); }) {
            return data.data();
          } else {
            return data;
          }
        }(data),
        [](const auto data) {
          if constexpr (requires { data.size(); }) {
            return data.size();
          } else {
            return 0u;  // unknown size
          }
        }(data, std::forward<decltype(args)>(args)...));
  }

 private:
  template <auto I>
  [[nodiscard]] constexpr auto operator()(const auto ptr, const auto size, auto &&...args) const noexcept(true) -> std::size_t {
    if constexpr (I == std::tuple_size_v<TPolicies>) {
      static_assert([](auto &&) { return false; }(ptr), "hash can't be constructed with given policies!");
      return {};
    } else if constexpr (requires { std::get<I>(policies)(symbols, ptr, size, std::forward<decltype(args)>(args)...); }) {
      return std::get<I>(policies)(symbols, ptr, size, std::forward<decltype(args)>(args)...);
    } else {
      return this->template operator()<I+1>(ptr, size, std::forward<decltype(args)>(args)...);
    }
  }

  TSymbols symbols{};
  TPolicies policies{};
};
}  // namespace mph::inline v_1_0_0

#if defined(MPH_TEST)
int main() {
  {
    static constexpr std::array<std::string_view, 3> symbols{
        "A",
        "B",
        "C",
    };

    constexpr auto hash = mph::hash{[] { return symbols; }};

    auto expected = 1u;
    for (const auto &symbol : symbols) {
      assert(expected++ == hash(symbol));
    }

    // assert(0 == mph::hash{symbols}(""));
    // assert(0 == mph::hash{symbols}("D"));
    // assert(0 == mph::hash{symbols}("a"));
    // assert(0 == mph::hash{symbols}("b"));
  }

  {
    static constexpr std::array<std::string_view, 3> symbols{
        "A",
        "B",
        "C",
    };

    auto hash = mph::hash{[] { return symbols; }};

    auto expected = 1u;
    for (const auto &symbol : symbols) {
      assert(expected++ == hash(symbol.data()));
    }

    // assert(0 == mph::hash{symbols}(""));
    // assert(0 == mph::hash{symbols}("D"));
    // assert(0 == mph::hash{symbols}("a"));
    // assert(0 == mph::hash{symbols}("b"));
  }

  {
    static constexpr std::array<std::string_view, 3> symbols{
        "AA ",
        "BB ",
        "CC ",
    };

    auto hash = mph::hash{[] { return symbols; }};

    auto expected = 1u;
    for (const auto &symbol : symbols) {
      assert(expected++ == hash(symbol.data()));
    }

    // assert(0 == mph::hash{symbols}(""));
    // assert(0 == mph::hash{symbols}("   "));
    // assert(0 == mph::hash{symbols}("aa "));
    // assert(0 == mph::hash{symbols}("aaa"));
    // assert(0 == mph::hash{symbols}("bb"));
    // assert(0 == mph::hash{symbols}("bb "));
    // assert(0 == mph::hash{symbols}(" cc"));
  }

  {
    static constexpr std::array<std::string_view, 3> symbols{
        " AA ",
        " AB ",
        " AC ",
    };

    auto hash = mph::hash{[] { return symbols; }};

    auto expected = 1u;
    for (const auto &symbol : symbols) {
      assert(expected++ == hash(symbol.data()));
    }

    // assert(0 == mph::hash{symbols}(""));
    // assert(0 == mph::hash{symbols}(" aa "));
    // assert(0 == mph::hash{symbols}("aaaa"));
    // assert(0 == mph::hash{symbols}(" AA"));
    // assert(0 == mph::hash{symbols}("AA "));
    // assert(0 == mph::hash{symbols}(" AA_"));
    // assert(0 == mph::hash{symbols}("_AA_"));
  }

  {
    static constexpr std::array<std::string_view, 100> symbols{
        "III     ", "AGM-C   ", "LOPE    ", "FEMS    ", "IEA     ", "VYMI    ", "BHK     ", "SIEB    ", "DGBP    ", "INFN    ",
        "USRT    ", "BCOR    ", "TWM     ", "BVSN    ", "STBA    ", "GPK     ", "LVHD    ", "FTEK    ", "GLBS    ", "CUBB    ",
        "LRCX    ", "HTGM    ", "RYN     ", "IPG     ", "PNNTG   ", "ZIG     ", "IVR-A   ", "INVA    ", "MNE     ", "KRA     ",
        "BRMK    ", "ARKG    ", "FFR     ", "QTRX    ", "XTN     ", "BAC-A   ", "CYBE    ", "ETJ     ", "JHCS    ", "RBCAA   ",
        "GDS     ", "WTID    ", "TCO     ", "BWA     ", "MIE     ", "GENY    ", "TDOC    ", "MCRO    ", "QFIN    ", "NBTB    ",
        "PWC     ", "FQAL    ", "NJAN    ", "IWB     ", "GXGXW   ", "EDUC    ", "RETL    ", "VIACA   ", "KLDO    ", "NEE-I   ",
        "FBC     ", "JW.A    ", "BSMX    ", "FMNB    ", "EXR     ", "TAC     ", "FDL     ", "SWIR    ", "CLWT    ", "LMHB    ",
        "IRTC    ", "CDMO    ", "HMLP-A  ", "LVUS    ", "UMRX    ", "GJH     ", "FRME    ", "CEIX    ", "IHD     ", "GHSI    ",
        "DCP-B   ", "SB      ", "DSE     ", "CPRT    ", "NRZ     ", "VLYPO   ", "TDAC    ", "ZXZZT   ", "IWX     ", "NCSM    ",
        "WIRE    ", "SFST    ", "EWD     ", "DEACW   ", "TRPX    ", "UCTT    ", "ZAZZT   ", "CYD     ", "NURE    ", "WEAT    ",
    };

    auto hash = mph::hash{[] { return symbols; }};

    auto expected = 1u;
    for (const auto &symbol : symbols) {
      assert(expected++ == hash(symbol.data()));
    }

    // assert(0 == mph::hash{symbols}(""));
    // assert(0 == mph::hash{symbols}("        "));
    // assert(0 == mph::hash{symbols}("III "));
    // assert(0 == mph::hash{symbols}("III  "));
    // assert(0 == mph::hash{symbols}("III   "));
    // assert(0 == mph::hash{symbols}("III    "));
    // assert(0 == mph::hash{symbols}("III     "));
    // assert(0 == mph::hash{symbols}(" III    "));
    // assert(0 == mph::hash{symbols}("IIIx    "));
    // assert(0 == mph::hash{symbols}("     III"));
  }
}
#endif  // MPH_TEST
#endif  // MPH
#endif  //  __cplusplus
