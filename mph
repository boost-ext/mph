//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#if __cplusplus < 202002L
#error "MPH requires C++20!"
#else

#if defined(__cpp_modules)
export module mph;
#endif

#ifndef MPH
#define MPH 1'0'0 // SemVer - should match mph namespace

#include <algorithm>
#include <climits>
#include <array>
#include <bit>
#include <cassert>
#include <cstring>
#include <cstdint>
#include <new>
#include <numeric>
#include <ranges>
#include <string_view>
#include <span>
#include <type_traits>
#include <vector>

#if __has_include(<x86intrin.h>)
#include <x86intrin.h>
#endif

#if defined(__cpp_modules)
export
#endif

/**
 * Minimal perfect hash function library (https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function)
 * The library requires C++20 and is generic purpose
 * Current version mainly focuses on x86-64
 */
namespace mph::inline v_1_0_0 {
namespace utility {
#if defined(__cpp_lib_hardware_interference_size)
static constexpr auto cache_line_size = ::std::hardware_constructive_interference_size;
#else
static constexpr auto cache_line_size = 64;  // x86-64
#endif

template <std::size_t N>
  requires(N > 0u)
struct bitset final {
  constexpr explicit(true) bitset(const auto value) {
    for (std::size_t i{}; i < N; ++i) {
      bits[i] = value & (1ull << i);
    }
  }
  constexpr auto set(const auto i, const auto value) { bits[i] = value; }
  [[nodiscard]] constexpr auto size() const { return std::size(bits); }
  [[nodiscard]] constexpr auto operator[](const auto i) const { return bits[i]; }
  template <class T>
  [[nodiscard]] constexpr auto to() const -> T
    requires(sizeof(T) * CHAR_BIT >= N)
  {
    T result{};
    for (auto i = 0u; i < N; ++i) {
      result |= static_cast<T>(bits[i]) << i;
    }
    return result;
  }
 private:
  std::array<bool, N> bits{};
};

// clang-format off
static_assert(1 == bitset<1>{1}[0]);
static_assert(0 == bitset<1>{0}[0]);
static_assert(1 == bitset<2>{0b01}[0]);
static_assert(0 == bitset<2>{0b01}[1]);
static_assert(0b01 == bitset<2>{0b01}.to<int>());
static_assert(0b10 == bitset<2>{0b10}.to<int>());
// clang-format on

template <class T>
[[nodiscard]] constexpr auto as(const auto value) -> T {
  T result{};
  for (auto i = 0u; i < std::min(std::size(value), sizeof(T)); ++i) {
    result = (result << CHAR_BIT) | value[std::min(std::size(value), sizeof(T)) - 1 - i];  // little-endian
  }
  return result;
}

// clang-format off
static_assert(std::is_same_v<std::uint16_t, decltype(as<std::uint16_t>(std::array<std::uint8_t, 2>{0, 1}))>);
static_assert(std::uint32_t(0b00000001'00000000) == as<std::uint16_t>(std::array<std::uint8_t, 2>{0, 1}));
static_assert(std::is_same_v<std::uint16_t, decltype(as<std::uint16_t>( std::array<std::uint8_t, 2>{1, 0}))>);
static_assert(std::uint32_t(0b00000000'00000001) == as<std::uint16_t>(std::array<std::uint8_t, 2>{1, 0}));
static_assert(std::is_same_v<std::uint8_t, decltype(as<std::uint8_t>(std::string_view{"a"}))>);
static_assert(std::uint8_t('a') == as<std::uint8_t>(std::string_view{"a"}));
static_assert(std::is_same_v<std::uint32_t, decltype(as<std::uint32_t>(std::array<std::uint8_t, 4>{ 'a', 'b', 0, 0}))>);
static_assert(((std::uint32_t('b') << CHAR_BIT) | std::uint32_t('a') << 0) == as<std::uint32_t>(std::array<std::uint8_t, 4>{'a', 'b', 0, 0}));
static_assert(std::is_same_v<std::uint32_t, decltype(as<std::uint32_t>(std::array<std::uint8_t, 4>{0, 0, 'a', 'b'}))>);
static_assert(((std::uint32_t('b') << CHAR_BIT*3) | std::uint32_t('a') << CHAR_BIT*2) == as<std::uint32_t>(std::array<std::uint8_t, 4>{0, 0, 'a', 'b'}));
// clang-format on

/**
 * https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=pext
 *
 * DO WHILE m < 64
 * 	IF mask[m] == 1
 * 		dst[k] := tmp[m]
 * 		k := k + 1
 * 	FI
 * 	m := m + 1
 * OD
 */
template <class T>
[[nodiscard]] constexpr auto pext(const T a, T mask) {
  T result{};
  auto k = 0u;
  auto m = 0u;
  while (m < sizeof(T) * CHAR_BIT) {
    if ((mask & 1) == 1) { // little endian
      result |= ((a >> m) & 1) << k++;
    }
    mask >>= 1;
    ++m;
  }
  return result;
}

// clang-format off
static_assert(0b00 == pext(0b00, 0b00));
static_assert(0b00 == pext(0b01, 0b00));
static_assert(0b01 == pext(0b01, 0b01));
static_assert(0b01 == pext(0b01, 0b11));
static_assert(0b00 == pext(0b01, 0b10));
static_assert(0b01 == pext(0b11, 0b10));
static_assert(0b01 == pext(0b11, 0b01));
static_assert(0b11 == pext(0b11, 0b11));
// clang-format on

/**
 * Finds T type mask which uniquely identifies given symbols
 */
template <class T>
[[nodiscard]] constexpr auto find_mask(const std::ranges::range auto &symbols) {
  const auto is_unique = [&](const auto mask) {
    std::vector<T> v{};
    for (const auto &symbol : symbols) {
      const auto value = pext(as<T>(symbol), mask.template to<T>());
      if (std::find(std::cbegin(v), std::cend(v), value) != std::cend(v)) {
        return false;
      }
      v.push_back(value);
    }
    return true;
  };

  bitset<sizeof(T) * CHAR_BIT> mask(std::numeric_limits<T>::max());
  for (auto i = 0u; i < std::size(mask); ++i) {
    mask.set(i, 0);
    if (not is_unique(mask)) {
      mask.set(i, 1);
    }
  }
  if (not is_unique(mask)) {
    throw;  // not a constant
  }
  return mask.template to<T>();
}

// clang-format off
static_assert(0b00000000'00000001 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 0}, std::array<std::uint8_t, 2>{0, 0}}));
static_assert(0b00000001'00000000 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{0, 0}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000001'00000000 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 0}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000001'00000000 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{0, 1}, std::array<std::uint8_t, 2>{1, 0}}));
static_assert(0b00000001'00000000 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 1}, std::array<std::uint8_t, 2>{1, 0}}));
static_assert(0b00000000'00000001 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 2>{1, 1}, std::array<std::uint8_t, 2>{0, 1}}));
static_assert(0b00000000'00000001'00000001 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{1, 1, 1}, std::array<std::uint8_t, 3>{0, 0, 0}, std::array<std::uint8_t, 3>{1, 0, 1}}));
static_assert(0b00000000'00000001'00000001 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{0, 0, 1}, std::array<std::uint8_t, 3>{1, 0, 1}, std::array<std::uint8_t, 3>{1, 1, 0}}));
static_assert(0b00000000'00000001'00000001 == find_mask<std::uint16_t>(std::array{ std::array<std::uint8_t, 3>{0, 0, 0}, std::array<std::uint8_t, 3>{1, 1, 1}, std::array<std::uint8_t, 3>{0, 1, 0}}));
// clang-format on

template<class... Ts> struct overloaded final : Ts... { using Ts::operator()...; };
template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

// clang-format off
static_assert(42 == overloaded{[](auto v) { return v; }}(42));
static_assert(1 == overloaded{[](int) { return 1; }, [](bool) { return 2; }}(int{}));
static_assert(2 == overloaded{[](int) { return 1; }, [](bool) { return 2; }}(bool{}));
// clang-format on

namespace detail {
template<const auto value>
inline constexpr auto unsigned_value_v = [] { // required for gcc ICE with decltype([]{...})
  if constexpr (value <= std::numeric_limits<std::uint8_t>::max()) {
    return std::uint8_t{};
  } else if constexpr (value <= std::numeric_limits<std::uint16_t>::max()) {
    return std::uint16_t{};
  } else if constexpr (value <= std::numeric_limits<std::uint32_t>::max()) {
    return std::uint32_t{};
  } else if constexpr (value <= std::numeric_limits<std::uint64_t>::max()) {
    return std::uint64_t{};
  }
};
} // namespace detail
template<const auto value> using unsigned_value_t = decltype(detail::unsigned_value_v<value>());

// clang-format off
static_assert(std::is_same_v<std::uint8_t, unsigned_value_t<0>>);
static_assert(std::is_same_v<std::uint16_t, unsigned_value_t<std::uint16_t(std::numeric_limits<std::uint8_t>::max())+1>>);
static_assert(std::is_same_v<std::uint32_t, unsigned_value_t<std::uint32_t(std::numeric_limits<std::uint16_t>::max())+1>>);
static_assert(std::is_same_v<std::uint64_t, unsigned_value_t<std::uint64_t(std::numeric_limits<std::uint32_t>::max())+1>>);
// clang-format on

template<class T, const auto cache_line_size, const bool unsafe = true>
[[nodiscard]] auto copy_required_bytes(const auto data) {
  if constexpr (T t{}; requires { std::bool_constant<(data.size(), true)>{}; }) {
    static_assert(std::size(data) <= sizeof(T));
    std::memcpy(std::addressof(t), std::data(data), std::size(data));
    return t; // should generate the same code as *std::bit_cast<const T*>(std::data(data))
  } else if constexpr (unsafe) {
    std::memcpy(std::addressof(t), std::data(data), sizeof(T)); // [[unsafe]] might be outside of std::size(data)
    static constexpr const auto masks = [] {
      alignas(cache_line_size) std::array<T, sizeof(T)+1> array{}; // +1 for leading 0u
      for (auto i = 0u; i < sizeof(T); ++i) {
        array[i+1] = array[i] | (T(0xFF) << (i * CHAR_BIT)); // little endian
      }
      return array;
    }();
    assert(std::size(data) < std::size(masks));
    return t & masks[std::size(data)]; // only use valid bytes
  } else {
    union { // type punning with `memcpy`
      std::uint8_t storage[sizeof(T)];
      T value;
    };
    value = {};
    std::memcpy(storage, std::data(data), std::size(data));
    return value;
  }
}
}  // namespace utility

namespace concepts {
template <const std::uint64_t mask, const std::size_t max_bits_size>
concept required_bits_size = (std::popcount(mask) <= max_bits_size);

// clang-format off
static_assert(required_bits_size<0b00, 0u>);
static_assert(required_bits_size<0b00, 1u>);
static_assert(required_bits_size<0b00, 2u>);
static_assert(required_bits_size<0b10, 2u>);
static_assert(required_bits_size<0b01, 2u>);
static_assert(not required_bits_size<0b01, 0>);
static_assert(not required_bits_size<0b10, 0>);
static_assert(not required_bits_size<0b11, 1>);
// clang-format on

template <const auto masks, const std::size_t max_bits_size>
concept required_symbols_bits_size = std::all_of(std::cbegin(masks), std::cend(masks), [](const auto mask) {
  return std::size_t(std::popcount(mask)) <= max_bits_size;
});

// clang-format off
static_assert(required_symbols_bits_size<std::array{0b00u, 0b00u}, 0u>);
static_assert(required_symbols_bits_size<std::array{0b01u, 0b01u}, 1u>);
static_assert(required_symbols_bits_size<std::array{0b10u, 0b01u}, 1u>);
static_assert(not required_symbols_bits_size<std::array{0b01u, 0b01u}, 0u>);
static_assert(not required_symbols_bits_size<std::array{0b11u, 0b10u}, 1u>);
static_assert(not required_symbols_bits_size<std::array{0b10u, 0b11u}, 1u>);
static_assert(not required_symbols_bits_size<std::array{0b11u, 0b11u}, 1u>);
// clang-format on

template <class TSymbols, std::size_t size>
concept per_symbols_size_gt = [](const auto &symbols) {
  return std::all_of(std::cbegin(symbols), std::cend(symbols), [](const auto &symbol) { return std::size(symbol) > size; });
}(TSymbols{}());

// clang-format off
static_assert(not per_symbols_size_gt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 2u>);
static_assert(not per_symbols_size_gt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 3u>);
static_assert(per_symbols_size_gt<decltype([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }), 0u>);
static_assert(per_symbols_size_gt<decltype([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }), 0u>);
static_assert(per_symbols_size_gt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 1u>);
static_assert(per_symbols_size_gt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 1u>);
// clang-format on

template <class TSymbols, std::size_t size>
concept all_symbols_size_lt = [](const auto &symbols) {
  return std::all_of(std::cbegin(symbols), std::cend(symbols), [](const auto &symbol) { return std::size(symbol) <= size; });
}(TSymbols{}());

static_assert(not all_symbols_size_lt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 0u>);
static_assert(not all_symbols_size_lt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 1u>);
static_assert(all_symbols_size_lt<decltype([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }), 1u>);
static_assert(all_symbols_size_lt<decltype([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }), 2u>);
static_assert(all_symbols_size_lt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 2u>);
static_assert(all_symbols_size_lt<decltype([] { return std::array{std::array<char, 2>{}, std::array<char, 2>{}}; }), 3u>);

template <class TSymbols, std::size_t N>
concept unique_symbols_per_char = [](const auto &symbols) {
  for (const auto& symbol : symbols) {
      if (const auto count = std::count_if(std::cbegin(symbols), std::cend(symbols), [&symbol](const auto& s) { return s[N] == symbol[N]; }); count > 1) {
        return false;
      }
  }
  return true;
}(TSymbols{}());

// clang-format off
static_assert(not unique_symbols_per_char<decltype([] { return std::array{std::array<char, 1>{'a'}, std::array<char, 1>{'a'}}; }), 0u>);
static_assert(unique_symbols_per_char<decltype([] { return std::array{std::array<char, 1>{'a'}, std::array<char, 1>{'b'}}; }), 0u>);
static_assert(unique_symbols_per_char<decltype([] { return std::array{std::array<char, 1>{'b'}, std::array<char, 1>{'a'}}; }), 0u>);
// clang-format on
}  // namespace concepts

constexpr auto conditional = [](const auto cond, const auto lhs, const auto rhs) {
  return cond ? lhs : rhs; // generates jmp (x86-64)
};

constexpr auto branchless = [](const auto cond, const auto lhs, [[maybe_unused]] const auto rhs) {
  return cond * lhs; // generates cmov (x86-64)
};

template<class T = std::uint64_t, const std::size_t cache_line_size = utility::cache_line_size>
class swar {
 public:
  template <class TSymbols>
    requires concepts::all_symbols_size_lt<TSymbols, sizeof(T)>
  [[nodiscard]] constexpr auto operator()(const TSymbols symbols, auto&& data, [[maybe_unused]] auto &&...args) const noexcept(true) {
    return dispatch(symbols, utility::copy_required_bytes<T, cache_line_size, false>(data), std::make_index_sequence<std::size(symbols())>{});
  }

private:
  template<auto N, auto... Ns>
  [[nodiscard]] static constexpr auto dispatch(const auto symbols, const T value, std::index_sequence<N, Ns...>) {
    switch (value) {
      default:
        if constexpr (not sizeof...(Ns)) {
          return decltype(N){};
        } else {
          return dispatch(symbols, value, std::index_sequence<Ns...>{});
        }
      case utility::as<T>(symbols()[N]):
        return 1u+N;
    }
  }
};

/**
 * Minimal perfect hashing function based on pext with support up to 2^max_bits_size
 *  requires symbols to have size <= CHAR_BIT bytes
 *  requires platform with bmi2 support (https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set)
 */
template <const std::size_t max_bits_size = 5, const auto result_policy = conditional,
          const std::size_t cache_line_size = utility::cache_line_size>
class pext {
  template <class T, const auto mask, const std::size_t size>
  [[nodiscard]] static consteval auto make_lookup(const auto &symbols) {
    alignas(cache_line_size) std::array<T, size> lookup{};
    for (const auto &symbol : symbols()) {
      lookup[utility::pext(utility::as<T>(symbol), mask)] = utility::as<T>(symbol);
    }
    return lookup;
  }

  // clang-format off
  static_assert(std::array{0ul, 0ul} == make_lookup<std::size_t, 0b00ul, 2u>([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }));
  static_assert(std::array{utility::as<std::size_t>(std::array<char, 1>{2}), utility::as<std::size_t>(std::array<char, 1>{1})} == make_lookup<std::size_t, 0b01ul, 2u>([] { return std::array{std::array<char, 1>{1}, std::array<char, 1>{2}}; }));
  // clang-format on

  template <class T, const auto mask, const std::size_t size>
  [[nodiscard]] static consteval auto make_index(const auto &symbols) {
    alignas(cache_line_size) std::array<utility::unsigned_value_t<size>, size> index{};
    for (auto i = 0u; const auto &symbol : symbols()) {
      index[utility::pext(utility::as<T>(symbol), mask)] = ++i;
    }

    return index;
  }

  // clang-format off
  static_assert(std::array{std::uint8_t(2), std::uint8_t(0)} == make_index<std::size_t, 0b00ul, 2u>([] { return std::array{std::array<char, 1>{}, std::array<char, 1>{}}; }));
  static_assert(std::array{std::uint8_t(2), std::uint8_t(1)} == make_index<std::size_t, 0b01ul, 2u>([] { return std::array{std::array<char, 1>{1}, std::array<char, 1>{2}}; }));
  // clang-format on

 public:
  template <class TSymbols, class T = std::uint64_t, const auto mask = utility::find_mask<T>(TSymbols{}())>
    requires concepts::required_bits_size<mask, max_bits_size> and concepts::all_symbols_size_lt<TSymbols, sizeof(T)>
  [[nodiscard]] [[gnu::target("bmi2")]] auto operator()(const TSymbols symbols, auto&& data, [[maybe_unused]] auto &&...args) const noexcept(true) {
    constexpr auto required_size = [] {
      auto result{1u};
      for (auto i = 0u; i < std::popcount(mask); ++i) {
        result *= 2; // std::pow is not constexpr in libc++
      }
      return result;
    }();

    static constexpr const auto lookup = make_lookup<T, mask, required_size>(symbols);
    static constexpr const auto index = make_index<T, mask, required_size>(symbols);

    const auto lhs = utility::copy_required_bytes<T, cache_line_size>(data);
    const auto ext = _pext_u64(lhs, mask);
    return result_policy(lookup[ext] == lhs, index[ext], decltype(index[ext]){});
  }
};

template <const std::size_t max_bits_size = 5, const auto N = 0u,
          const auto result_policy = conditional,
          const std::size_t cache_line_size = utility::cache_line_size>
class pext_split {
  template<class T>
  [[nodiscard]] static consteval auto make_masks(const auto &symbols) {
    constexpr auto size = std::numeric_limits<std::remove_cvref_t<decltype(symbols()[0][0])>>::max();

    std::vector<std::vector<std::remove_cvref_t<decltype(symbols()[0])>>> v(size);
    for (const auto &symbol : symbols()) {
      v[std::size_t(symbol[N])].push_back(symbol);
    }

    std::array<T, size> masks{};
    for (auto i = 0u; i < std::size(masks); ++i) {
      masks[i] = utility::find_mask<T>(v[i]);
    }

    return masks;
  }

  template <class T, const auto masks, const std::size_t size>
  [[nodiscard]] static consteval auto make_lookups(const auto &symbols) {
    constexpr auto split_size = std::numeric_limits<std::remove_cvref_t<decltype(symbols()[0][0])>>::max();

    std::vector<std::remove_cvref_t<decltype(symbols()[0])>> v[split_size]{};
    for (const auto &symbol : symbols()) {
      v[std::size_t(symbol[N])].push_back(symbol);
    }

    alignas(cache_line_size) std::array<std::array<T, size>, split_size> lookup{};
    for (auto i = 0u; i < split_size; ++i) {
      for (auto j = 0u; j < std::size(v[i]); ++j) {
        lookup[i][utility::pext(utility::as<T>(v[i][j]), masks[i])] = utility::as<T>(v[i][j]);
      }
    }

    return lookup;
  }

  template <class T, const auto masks, const std::size_t size>
  [[nodiscard]] static consteval auto make_indexes(const auto &symbols) {
    constexpr auto split_size = std::numeric_limits<std::remove_cvref_t<decltype(symbols()[0][0])>>::max();

    std::vector<std::size_t> idx[split_size]{};
    std::vector<std::remove_cvref_t<decltype(symbols()[0])>> v[split_size]{};

    for (auto i = 0u; const auto &symbol : symbols()) {
      idx[std::size_t(symbol[N])].push_back(++i);
      v[std::size_t(symbol[N])].push_back(symbol);
    }

    alignas(cache_line_size) std::array<std::array<utility::unsigned_value_t<size>, size>, split_size> index{};
    for (auto i = 0u; i < split_size; ++i) {
      for (auto j = 0u; j < std::size(v[i]); ++j) {
        index[i][utility::pext(utility::as<T>(v[i][j]), masks[i])] = idx[i][j];
      }
    }

    return index;
  }

 public:
  template <class TSymbols, class T = std::uint64_t, const auto masks = make_masks<T>(TSymbols{})>
    requires concepts::required_symbols_bits_size<masks, max_bits_size> and concepts::all_symbols_size_lt<TSymbols, sizeof(T)>
  [[nodiscard]] [[gnu::target("bmi2")]] auto operator()(const TSymbols symbols, const auto data, [[maybe_unused]] auto &&...args) const noexcept(true) {
    constexpr auto required_size = [] {
      std::vector<std::size_t> sizes{};
      std::transform(std::cbegin(masks), std::cend(masks), std::back_inserter(sizes), [](const auto mask) { return std::popcount(mask); });
      const auto max_size = std::max_element(std::cbegin(sizes), std::cend(sizes));
      auto result{1u};
      for (auto i = 0u; i < *max_size; ++i) {
        result *= 2; // std::pow is not constexpr in libc++
      }
      return result;
    }();

    static constexpr auto lookup = make_lookups<T, masks, required_size>(symbols);
    static constexpr auto index = make_indexes<T, masks, required_size>(symbols);

    assert(std::size(data) > N);
    const auto id = data[N];
    const auto lhs = utility::copy_required_bytes<T, cache_line_size>(data);
    const auto ext = _pext_u64(lhs, masks[id]);
    return result_policy(lookup[id][ext] == lhs, index[id][ext], decltype(index[id][ext]){});
  }
};

/**
 * Default implementation for picking the policy based on the symbols, available policies and the input data
 * Will fail to compile if policies don't return the same type
 *
 * @param symbols constexpr list of symbols
 * @param data input data
 * @param args... additional args propagated to policies
 * @return depends on the policies [default: 0 if string doesn't match, 1..N for matches]
 */
constexpr auto default_policies = [](const auto symbols, auto&& data, auto &&...args) {
  constexpr auto max_bits_size = 5;
  constexpr auto pext = mph::pext<max_bits_size>{};

  constexpr auto char_index = 0u;
  constexpr auto pext_split = mph::pext_split<max_bits_size, char_index>{};

  constexpr auto swar_32 = mph::swar<std::uint32_t>{};
  constexpr auto swar_64 = mph::swar<std::uint64_t>{};

  if constexpr (requires { pext(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...); }) {
    return pext(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...);
  } else if constexpr (requires { pext_split(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...); }) {
    return pext_split(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...);
  } else if constexpr (requires { swar_32(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...); }) {
    return swar_32(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...);
  } else if constexpr (requires { swar_64(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...); }) {
    return swar_64(symbols, std::forward<decltype(data)>(data), std::forward<decltype(args)>(args)...);
  } else {
    constexpr auto hash_cant_be_created = [](auto &&) { return false; }(symbols);  // static_assert(false) support is C++23
    static_assert(hash_cant_be_created, "hash can't be created with given policies!");
  }
};

/**
 * Minimal perfect hash function (https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function)
 *
 * @tparam TSymbols compile time array of symbols
 * @tparam TPolicies compile time policies to be executed in given order
 */
template <std::invocable TSymbols, class TPolicies = decltype(default_policies)>
  requires (std::size(TSymbols{}()) > 0u)
  //requires range and size on each element of the range
class hash final {
 public:
  static constexpr auto symbols = TSymbols{};
  static constexpr auto policies = TPolicies{};

  constexpr explicit(true) hash(const TSymbols &, const TPolicies & = {}) {} // for CTAD

  /**
   * @param data continuous input data such as std::string_view, std::span, std::array
   * @param args... additional parameters propagated to policies
   * @return result from executed policy
   */
  [[nodiscard]] constexpr auto operator()(auto&& data, auto &&...args) const noexcept(true) {
    constexpr auto min_max = // std::minmax_element is not constexpr
      [] {
        const auto& v = symbols();
        auto min = std::size(v[0]);
        auto max = std::size(v[0]);
        for (const auto& symbol : v) {
          min = std::min(min, std::size(symbol));
          max = std::max(max, std::size(symbol));
        }
        return std::pair{min, max};
      }();

    return utility::overloaded{
      [&]<class T, class... Ts> requires (sizeof(T) == 1u) (const std::basic_string_view<T, Ts...> sv) {
        if (const auto size = std::size(sv); size < min_max.first or size > min_max.second) {
          return decltype(policies(symbols, sv, std::forward<decltype(args)>(args)...)){};
        }
        assert(std::size(sv) > 0u);
        return policies(symbols, sv, std::forward<decltype(args)>(args)...);
      },
      [&]<class T, const std::size_t Size> requires (sizeof(T) == 1u) (const std::span<T, Size> span) {
        if constexpr (Size != std::dynamic_extent and (Size < min_max.first or Size > min_max.second)) {
          return decltype(policies(symbols, span, std::forward<decltype(args)>(args)...)){};
        } else {
          if (const auto size = std::size(span); size < min_max.first or size > min_max.second) {
            return decltype(policies(symbols, span, std::forward<decltype(args)>(args)...)){};
          }
          assert(std::size(span) > 0u);
          return policies(symbols, span, std::forward<decltype(args)>(args)...);
        }
      },
      [&]<class T, const std::size_t Size> requires (sizeof(T) == 1u) (const std::array<T, Size>& array) {
        if constexpr (Size < min_max.first or Size > min_max.second) {
          return decltype(policies(symbols, array, std::forward<decltype(args)>(args)...)){};
        } else {
          return policies(symbols, array, std::forward<decltype(args)>(args)...);
        }
      },
    }(std::forward<decltype(data)>(data));
  }
};
}  // namespace mph::inline v_1_0_0

#endif  // MPH
#endif  //  __cplusplus
